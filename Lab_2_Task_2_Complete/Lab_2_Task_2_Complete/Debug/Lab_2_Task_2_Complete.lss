
Lab_2_Task_2_Complete.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000030e4  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80005200  80005200  00005600  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000002b0  80005400  80005400  00005800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         00000004  00000008  800056b0  00005c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  0000000c  800056b4  00005c0c  2**0
                  ALLOC
  8 .bss          00000728  00000010  00000010  00000000  2**2
                  ALLOC
  9 .heap         0000e8c8  00000738  00000738  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00005c0c  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000a18  00000000  00000000  00005c40  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00001ab7  00000000  00000000  00006658  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0000e032  00000000  00000000  0000810f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000018f1  00000000  00000000  00016141  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00007c1d  00000000  00000000  00017a32  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00001f00  00000000  00000000  0001f650  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    0000349b  00000000  00000000  00021550  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00002d85  00000000  00000000  000249eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00c11b44  00000000  00000000  00027770  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000968  00000000  00000000  00c392b8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf b8 14 	sub	pc,pc,-18412

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf d8 18 	sub	pc,pc,-10216

Disassembly of section .text:

80002008 <sd_mmc_spi_internal_init>:
80002008:	eb cd 40 80 	pushm	r7,lr
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_internal_init(void)
{
8000200c:	1a 97       	mov	r7,sp
8000200e:	20 3d       	sub	sp,12
  uint16_t retry;
  int i;
  int if_cond;

  // Start at low frequency
  sd_mmc_opt.baudrate = 400000;
80002010:	fe f8 02 c8 	ld.w	r8,pc[712]
80002014:	e6 69 1a 80 	mov	r9,400000
80002018:	91 19       	st.w	r8[0x4],r9
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
8000201a:	fe f8 02 c2 	ld.w	r8,pc[706]
8000201e:	70 08       	ld.w	r8,r8[0x0]
80002020:	10 9a       	mov	r10,r8
80002022:	fe fb 02 b6 	ld.w	r11,pc[694]
80002026:	fe 7c 28 00 	mov	r12,-55296
8000202a:	f0 1f 00 ae 	mcall	800022e0 <sd_mmc_spi_internal_init+0x2d8>

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
8000202e:	30 1b       	mov	r11,1
80002030:	fe 7c 28 00 	mov	r12,-55296
80002034:	f0 1f 00 ac 	mcall	800022e4 <sd_mmc_spi_internal_init+0x2dc>
  for(i = 0; i < 10; ++i) {
80002038:	30 08       	mov	r8,0
8000203a:	ef 48 ff f8 	st.w	r7[-8],r8
8000203e:	c0 c8       	rjmp	80002056 <sd_mmc_spi_internal_init+0x4e>
    spi_write(SD_MMC_SPI,0xFF);
80002040:	e0 6b 00 ff 	mov	r11,255
80002044:	fe 7c 28 00 	mov	r12,-55296
80002048:	f0 1f 00 a8 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
  sd_mmc_opt.baudrate = 400000;
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);

  /* card needs 74 cycles minimum to start up */
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
  for(i = 0; i < 10; ++i) {
8000204c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002050:	2f f8       	sub	r8,-1
80002052:	ef 48 ff f8 	st.w	r7[-8],r8
80002056:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000205a:	58 98       	cp.w	r8,9
8000205c:	fe 9a ff f2 	brle	80002040 <sd_mmc_spi_internal_init+0x38>
    spi_write(SD_MMC_SPI,0xFF);
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002060:	30 1b       	mov	r11,1
80002062:	fe 7c 28 00 	mov	r12,-55296
80002066:	f0 1f 00 a2 	mcall	800022ec <sd_mmc_spi_internal_init+0x2e4>

  // RESET THE MEMORY CARD
  sd_mmc_spi_init_done = false;
8000206a:	fe f9 02 86 	ld.w	r9,pc[646]
8000206e:	30 08       	mov	r8,0
80002070:	b2 88       	st.b	r9[0x0],r8
  card_type = MMC_CARD;
80002072:	fe f9 02 82 	ld.w	r9,pc[642]
80002076:	30 08       	mov	r8,0
80002078:	b2 88       	st.b	r9[0x0],r8
  retry = 0;
8000207a:	30 08       	mov	r8,0
8000207c:	ef 58 ff f6 	st.h	r7[-10],r8
  do
  {
    // reset card and go to SPI mode
    r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002080:	30 0b       	mov	r11,0
80002082:	30 0c       	mov	r12,0
80002084:	f0 1f 00 9d 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
80002088:	18 98       	mov	r8,r12
8000208a:	fe f9 02 72 	ld.w	r9,pc[626]
8000208e:	b2 88       	st.b	r9[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002090:	e0 6b 00 ff 	mov	r11,255
80002094:	fe 7c 28 00 	mov	r12,-55296
80002098:	f0 1f 00 94 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
    // do retry counter
    retry++;
8000209c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
800020a0:	2f f8       	sub	r8,-1
800020a2:	ef 58 ff f6 	st.h	r7[-10],r8
    if(retry > 100)
800020a6:	ef 09 ff f6 	ld.sh	r9,r7[-10]
800020aa:	36 48       	mov	r8,100
800020ac:	f0 09 19 00 	cp.h	r9,r8
800020b0:	e0 88 00 04 	brls	800020b8 <sd_mmc_spi_internal_init+0xb0>
      return false;
800020b4:	30 08       	mov	r8,0
800020b6:	c0 d9       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>
  }
  while(r1 != 0x01);   // check memory enters idle_state
800020b8:	fe f8 02 44 	ld.w	r8,pc[580]
800020bc:	11 89       	ld.ub	r9,r8[0x0]
800020be:	30 18       	mov	r8,1
800020c0:	f0 09 18 00 	cp.b	r9,r8
800020c4:	cd e1       	brne	80002080 <sd_mmc_spi_internal_init+0x78>

  if_cond = sd_mmc_spi_get_if();
800020c6:	f0 1f 00 8f 	mcall	80002300 <sd_mmc_spi_internal_init+0x2f8>
800020ca:	18 98       	mov	r8,r12
800020cc:	ef 48 ff fc 	st.w	r7[-4],r8
  if(if_cond == -1) {
800020d0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020d4:	5b f8       	cp.w	r8,-1
800020d6:	c0 31       	brne	800020dc <sd_mmc_spi_internal_init+0xd4>
      return false; // card is bad
800020d8:	30 08       	mov	r8,0
800020da:	cf b8       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>
  } else if (if_cond == 1) {
800020dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020e0:	58 18       	cp.w	r8,1
800020e2:	c0 61       	brne	800020ee <sd_mmc_spi_internal_init+0xe6>
      card_type = SD_CARD_2;
800020e4:	fe f9 02 10 	ld.w	r9,pc[528]
800020e8:	30 28       	mov	r8,2
800020ea:	b2 88       	st.b	r9[0x0],r8
800020ec:	c4 c8       	rjmp	80002184 <sd_mmc_spi_internal_init+0x17c>
  } else {
    // IDENTIFICATION OF THE CARD TYPE (SD or MMC)
    // Both cards will accept CMD55 command but only the SD card will respond to ACMD41
    r1 = sd_mmc_spi_send_command(SD_APP_CMD55,0);
800020ee:	30 0b       	mov	r11,0
800020f0:	33 7c       	mov	r12,55
800020f2:	f0 1f 00 82 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
800020f6:	18 98       	mov	r8,r12
800020f8:	fe f9 02 04 	ld.w	r9,pc[516]
800020fc:	b2 88       	st.b	r9[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
800020fe:	e0 6b 00 ff 	mov	r11,255
80002102:	fe 7c 28 00 	mov	r12,-55296
80002106:	f0 1f 00 79 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>

    r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
8000210a:	30 0b       	mov	r11,0
8000210c:	32 9c       	mov	r12,41
8000210e:	f0 1f 00 7b 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
80002112:	18 98       	mov	r8,r12
80002114:	4f a9       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
80002116:	b2 88       	st.b	r9[0x0],r8
    spi_write(SD_MMC_SPI,0xFF);  // write dummy byte
80002118:	e0 6b 00 ff 	mov	r11,255
8000211c:	fe 7c 28 00 	mov	r12,-55296
80002120:	f0 1f 00 72 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>

    if ((r1&0xFE) == 0) {   // ignore "in_idle_state" flag bit
80002124:	4f 68       	lddpc	r8,800022fc <sd_mmc_spi_internal_init+0x2f4>
80002126:	11 88       	ld.ub	r8,r8[0x0]
80002128:	e2 18 00 fe 	andl	r8,0xfe,COH
8000212c:	c0 51       	brne	80002136 <sd_mmc_spi_internal_init+0x12e>
      card_type = SD_CARD;    // card has accepted the command, this is a SD card
8000212e:	4f 29       	lddpc	r9,800022f4 <sd_mmc_spi_internal_init+0x2ec>
80002130:	30 18       	mov	r8,1
80002132:	b2 88       	st.b	r9[0x0],r8
80002134:	c2 88       	rjmp	80002184 <sd_mmc_spi_internal_init+0x17c>
    } else {
      card_type = MMC_CARD;   // card has not responded, this is a MMC card
80002136:	4f 09       	lddpc	r9,800022f4 <sd_mmc_spi_internal_init+0x2ec>
80002138:	30 08       	mov	r8,0
8000213a:	b2 88       	st.b	r9[0x0],r8
      // reset card again
      retry = 0;
8000213c:	30 08       	mov	r8,0
8000213e:	ef 58 ff f6 	st.h	r7[-10],r8
      do {
        // reset card again
        r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0);
80002142:	30 0b       	mov	r11,0
80002144:	30 0c       	mov	r12,0
80002146:	f0 1f 00 6d 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
8000214a:	18 98       	mov	r8,r12
8000214c:	4e c9       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000214e:	b2 88       	st.b	r9[0x0],r8
        spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002150:	e0 6b 00 ff 	mov	r11,255
80002154:	fe 7c 28 00 	mov	r12,-55296
80002158:	f0 1f 00 64 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
        // do retry counter
        retry++;
8000215c:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80002160:	2f f8       	sub	r8,-1
80002162:	ef 58 ff f6 	st.h	r7[-10],r8
        if(retry > 100)
80002166:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000216a:	36 48       	mov	r8,100
8000216c:	f0 09 19 00 	cp.h	r9,r8
80002170:	e0 88 00 04 	brls	80002178 <sd_mmc_spi_internal_init+0x170>
          return false;
80002174:	30 08       	mov	r8,0
80002176:	ca d8       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>
      }
      while(r1 != 0x01);   // check memory enters idle_state
80002178:	4e 18       	lddpc	r8,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000217a:	11 89       	ld.ub	r9,r8[0x0]
8000217c:	30 18       	mov	r8,1
8000217e:	f0 09 18 00 	cp.b	r9,r8
80002182:	ce 01       	brne	80002142 <sd_mmc_spi_internal_init+0x13a>
    }
  }

  // CONTINUE INTERNAL INITIALIZATION OF THE CARD
  // Continue sending CMD1 while memory card is in idle state
  retry = 0;
80002184:	30 08       	mov	r8,0
80002186:	ef 58 ff f6 	st.h	r7[-10],r8
  do {
    switch(card_type) {
8000218a:	4d b8       	lddpc	r8,800022f4 <sd_mmc_spi_internal_init+0x2ec>
8000218c:	11 88       	ld.ub	r8,r8[0x0]
8000218e:	58 18       	cp.w	r8,1
80002190:	c1 30       	breq	800021b6 <sd_mmc_spi_internal_init+0x1ae>
80002192:	58 28       	cp.w	r8,2
80002194:	c2 30       	breq	800021da <sd_mmc_spi_internal_init+0x1d2>
80002196:	58 08       	cp.w	r8,0
80002198:	c3 31       	brne	800021fe <sd_mmc_spi_internal_init+0x1f6>
    case MMC_CARD:
      r1 = sd_mmc_spi_send_command(MMC_SEND_OP_COND, 0);
8000219a:	30 0b       	mov	r11,0
8000219c:	30 1c       	mov	r12,1
8000219e:	f0 1f 00 57 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
800021a2:	18 98       	mov	r8,r12
800021a4:	4d 69       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
800021a6:	b2 88       	st.b	r9[0x0],r8
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800021a8:	e0 6b 00 ff 	mov	r11,255
800021ac:	fe 7c 28 00 	mov	r12,-55296
800021b0:	f0 1f 00 4e 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
      break;
800021b4:	c2 58       	rjmp	800021fe <sd_mmc_spi_internal_init+0x1f6>
    case SD_CARD:
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800021b6:	30 0b       	mov	r11,0
800021b8:	33 7c       	mov	r12,55
800021ba:	f0 1f 00 50 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0);
800021be:	30 0b       	mov	r11,0
800021c0:	32 9c       	mov	r12,41
800021c2:	f0 1f 00 4e 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
800021c6:	18 98       	mov	r8,r12
800021c8:	4c d9       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
800021ca:	b2 88       	st.b	r9[0x0],r8
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800021cc:	e0 6b 00 ff 	mov	r11,255
800021d0:	fe 7c 28 00 	mov	r12,-55296
800021d4:	f0 1f 00 45 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
      break;
800021d8:	c1 38       	rjmp	800021fe <sd_mmc_spi_internal_init+0x1f6>
    case SD_CARD_2:
      // set high capacity bit mask
      sd_mmc_spi_send_command(SD_APP_CMD55,0);
800021da:	30 0b       	mov	r11,0
800021dc:	33 7c       	mov	r12,55
800021de:	f0 1f 00 47 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
      r1 = sd_mmc_spi_send_command(SD_SEND_OP_COND_ACMD, 0x40000000);
800021e2:	fc 1b 40 00 	movh	r11,0x4000
800021e6:	32 9c       	mov	r12,41
800021e8:	f0 1f 00 44 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
800021ec:	18 98       	mov	r8,r12
800021ee:	4c 49       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
800021f0:	b2 88       	st.b	r9[0x0],r8
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
800021f2:	e0 6b 00 ff 	mov	r11,255
800021f6:	fe 7c 28 00 	mov	r12,-55296
800021fa:	f0 1f 00 3c 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
      break;
    }
     // do retry counter
     retry++;
800021fe:	ef 08 ff f6 	ld.sh	r8,r7[-10]
80002202:	2f f8       	sub	r8,-1
80002204:	ef 58 ff f6 	st.h	r7[-10],r8
     if(retry == 50000)    // measured approx. 500 on several cards
80002208:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000220c:	fe 78 c3 50 	mov	r8,-15536
80002210:	f0 09 19 00 	cp.h	r9,r8
80002214:	c0 31       	brne	8000221a <sd_mmc_spi_internal_init+0x212>
        return false;
80002216:	30 08       	mov	r8,0
80002218:	c5 c8       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>
  } while (r1);
8000221a:	4b 98       	lddpc	r8,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000221c:	11 88       	ld.ub	r8,r8[0x0]
8000221e:	58 08       	cp.w	r8,0
80002220:	cb 51       	brne	8000218a <sd_mmc_spi_internal_init+0x182>

  // CHECK FOR SDHC
  if(card_type == SD_CARD_2) {
80002222:	4b 58       	lddpc	r8,800022f4 <sd_mmc_spi_internal_init+0x2ec>
80002224:	11 89       	ld.ub	r9,r8[0x0]
80002226:	30 28       	mov	r8,2
80002228:	f0 09 18 00 	cp.b	r9,r8
8000222c:	c1 31       	brne	80002252 <sd_mmc_spi_internal_init+0x24a>
    if_cond = sd_mmc_spi_check_hc();
8000222e:	f0 1f 00 36 	mcall	80002304 <sd_mmc_spi_internal_init+0x2fc>
80002232:	18 98       	mov	r8,r12
80002234:	ef 48 ff fc 	st.w	r7[-4],r8
    if (if_cond == -1) {
80002238:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000223c:	5b f8       	cp.w	r8,-1
8000223e:	c0 31       	brne	80002244 <sd_mmc_spi_internal_init+0x23c>
      return false;
80002240:	30 08       	mov	r8,0
80002242:	c4 78       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>
    } else if (if_cond == 1){
80002244:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002248:	58 18       	cp.w	r8,1
8000224a:	c0 41       	brne	80002252 <sd_mmc_spi_internal_init+0x24a>
          card_type = SD_CARD_2_SDHC;
8000224c:	4a a9       	lddpc	r9,800022f4 <sd_mmc_spi_internal_init+0x2ec>
8000224e:	30 38       	mov	r8,3
80002250:	b2 88       	st.b	r9[0x0],r8
      }
  }

  // DISABLE CRC TO SIMPLIFY AND SPEED UP COMMUNICATIONS
  r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0);  // disable CRC (should be already initialized on SPI init)
80002252:	30 0b       	mov	r11,0
80002254:	33 bc       	mov	r12,59
80002256:	f0 1f 00 29 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
8000225a:	18 98       	mov	r8,r12
8000225c:	4a 89       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000225e:	b2 88       	st.b	r9[0x0],r8
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002260:	e0 6b 00 ff 	mov	r11,255
80002264:	fe 7c 28 00 	mov	r12,-55296
80002268:	f0 1f 00 20 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>

  // SET BLOCK LENGTH TO 512 BYTES
  r1 = sd_mmc_spi_send_command(MMC_SET_BLOCKLEN, 512);
8000226c:	e0 6b 02 00 	mov	r11,512
80002270:	31 0c       	mov	r12,16
80002272:	f0 1f 00 22 	mcall	800022f8 <sd_mmc_spi_internal_init+0x2f0>
80002276:	18 98       	mov	r8,r12
80002278:	4a 19       	lddpc	r9,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000227a:	b2 88       	st.b	r9[0x0],r8
  spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
8000227c:	e0 6b 00 ff 	mov	r11,255
80002280:	fe 7c 28 00 	mov	r12,-55296
80002284:	f0 1f 00 19 	mcall	800022e8 <sd_mmc_spi_internal_init+0x2e0>
  if (r1 != 0x00)
80002288:	49 d8       	lddpc	r8,800022fc <sd_mmc_spi_internal_init+0x2f4>
8000228a:	11 88       	ld.ub	r8,r8[0x0]
8000228c:	58 08       	cp.w	r8,0
8000228e:	c0 30       	breq	80002294 <sd_mmc_spi_internal_init+0x28c>
    return false;    // card unsupported if block length of 512b is not accepted
80002290:	30 08       	mov	r8,0
80002292:	c1 f8       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>

  // GET CARD SPECIFIC DATA
  if (false ==  sd_mmc_spi_get_csd(csd))
80002294:	49 dc       	lddpc	r12,80002308 <sd_mmc_spi_internal_init+0x300>
80002296:	f0 1f 00 1e 	mcall	8000230c <sd_mmc_spi_internal_init+0x304>
8000229a:	18 98       	mov	r8,r12
8000229c:	ec 18 00 01 	eorl	r8,0x1
800022a0:	5c 58       	castu.b	r8
800022a2:	c0 30       	breq	800022a8 <sd_mmc_spi_internal_init+0x2a0>
    return false;
800022a4:	30 08       	mov	r8,0
800022a6:	c1 58       	rjmp	800022d0 <sd_mmc_spi_internal_init+0x2c8>

  // GET CARD CAPACITY and NUMBER OF SECTORS
  sd_mmc_spi_get_capacity();
800022a8:	f0 1f 00 1a 	mcall	80002310 <sd_mmc_spi_internal_init+0x308>
#if (defined SD_MMC_READ_CID) && (SD_MMC_READ_CID == true)
  if (false ==  sd_mmc_spi_get_cid(cid))
    return false;
#endif

  sd_mmc_spi_init_done = true;
800022ac:	49 19       	lddpc	r9,800022f0 <sd_mmc_spi_internal_init+0x2e8>
800022ae:	30 18       	mov	r8,1
800022b0:	b2 88       	st.b	r9[0x0],r8

  // Set SPI Speed to MAX
  sd_mmc_opt.baudrate = SD_MMC_SPI_MASTER_SPEED;
800022b2:	48 a8       	lddpc	r8,800022d8 <sd_mmc_spi_internal_init+0x2d0>
800022b4:	e0 69 1b 00 	mov	r9,6912
800022b8:	ea 19 00 b7 	orh	r9,0xb7
800022bc:	91 19       	st.w	r8[0x4],r9
  spi_setupChipReg(SD_MMC_SPI, &sd_mmc_opt, sd_mmc_pba_hz);
800022be:	48 88       	lddpc	r8,800022dc <sd_mmc_spi_internal_init+0x2d4>
800022c0:	70 08       	ld.w	r8,r8[0x0]
800022c2:	10 9a       	mov	r10,r8
800022c4:	48 5b       	lddpc	r11,800022d8 <sd_mmc_spi_internal_init+0x2d0>
800022c6:	fe 7c 28 00 	mov	r12,-55296
800022ca:	f0 1f 00 06 	mcall	800022e0 <sd_mmc_spi_internal_init+0x2d8>
  return true;
800022ce:	30 18       	mov	r8,1
}
800022d0:	10 9c       	mov	r12,r8
800022d2:	2f dd       	sub	sp,-12
800022d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800022d8:	00 00       	add	r0,r0
800022da:	00 10       	sub	r0,r0
800022dc:	00 00       	add	r0,r0
800022de:	00 20       	rsub	r0,r0
800022e0:	80 00       	ld.sh	r0,r0[0x0]
800022e2:	3b 94       	mov	r4,-71
800022e4:	80 00       	ld.sh	r0,r0[0x0]
800022e6:	3a 90       	mov	r0,-87
800022e8:	80 00       	ld.sh	r0,r0[0x0]
800022ea:	3d 32       	mov	r2,-45
800022ec:	80 00       	ld.sh	r0,r0[0x0]
800022ee:	3b 28       	mov	r8,-78
800022f0:	00 00       	add	r0,r0
800022f2:	00 24       	rsub	r4,r0
800022f4:	00 00       	add	r0,r0
800022f6:	03 2a       	ld.uh	r10,r1++
800022f8:	80 00       	ld.sh	r0,r0[0x0]
800022fa:	23 54       	sub	r4,53
800022fc:	00 00       	add	r0,r0
800022fe:	03 3c       	ld.ub	r12,r1++
80002300:	80 00       	ld.sh	r0,r0[0x0]
80002302:	25 08       	sub	r8,80
80002304:	80 00       	ld.sh	r0,r0[0x0]
80002306:	25 e8       	sub	r8,94
80002308:	00 00       	add	r0,r0
8000230a:	03 2c       	ld.uh	r12,r1++
8000230c:	80 00       	ld.sh	r0,r0[0x0]
8000230e:	26 a4       	sub	r4,106
80002310:	80 00       	ld.sh	r0,r0[0x0]
80002312:	27 e8       	sub	r8,126

80002314 <sd_mmc_spi_init>:
//!
//!
//! @return bit
//!   The memory is ready     -> true (always)
bool sd_mmc_spi_init(spi_options_t spiOptions, unsigned int pba_hz)
{
80002314:	eb cd 40 80 	pushm	r7,lr
80002318:	1a 97       	mov	r7,sp
8000231a:	20 1d       	sub	sp,4
8000231c:	ee c8 ff f8 	sub	r8,r7,-8
80002320:	ef 4c ff fc 	st.w	r7[-4],r12
  // Keep SPI options internally
  sd_mmc_pba_hz = pba_hz;
80002324:	48 89       	lddpc	r9,80002344 <sd_mmc_spi_init+0x30>
80002326:	ee fa ff fc 	ld.w	r10,r7[-4]
8000232a:	93 0a       	st.w	r9[0x0],r10
  memcpy( &sd_mmc_opt, &spiOptions, sizeof(spi_options_t) );
8000232c:	31 0a       	mov	r10,16
8000232e:	10 9b       	mov	r11,r8
80002330:	48 6c       	lddpc	r12,80002348 <sd_mmc_spi_init+0x34>
80002332:	f0 1f 00 07 	mcall	8000234c <sd_mmc_spi_init+0x38>

  // Initialize the SD/MMC controller.
  return sd_mmc_spi_internal_init();
80002336:	f0 1f 00 07 	mcall	80002350 <sd_mmc_spi_init+0x3c>
8000233a:	18 98       	mov	r8,r12
}
8000233c:	10 9c       	mov	r12,r8
8000233e:	2f fd       	sub	sp,-4
80002340:	e3 cd 80 80 	ldm	sp++,r7,pc
80002344:	00 00       	add	r0,r0
80002346:	00 20       	rsub	r0,r0
80002348:	00 00       	add	r0,r0
8000234a:	00 10       	sub	r0,r0
8000234c:	80 00       	ld.sh	r0,r0[0x0]
8000234e:	4f a4       	lddpc	r4,80002534 <sd_mmc_spi_get_if+0x2c>
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	20 08       	sub	r8,0

80002354 <sd_mmc_spi_send_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF if time out error)
uint8_t sd_mmc_spi_send_command(uint8_t command, uint32_t arg)
{
80002354:	eb cd 40 80 	pushm	r7,lr
80002358:	1a 97       	mov	r7,sp
8000235a:	20 2d       	sub	sp,8
8000235c:	18 98       	mov	r8,r12
8000235e:	ef 4b ff f8 	st.w	r7[-8],r11
80002362:	ef 68 ff fc 	st.b	r7[-4],r8
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002366:	30 1b       	mov	r11,1
80002368:	fe 7c 28 00 	mov	r12,-55296
8000236c:	f0 1f 00 0c 	mcall	8000239c <sd_mmc_spi_send_command+0x48>
  r1 = sd_mmc_spi_command(command, arg);
80002370:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80002374:	ee fb ff f8 	ld.w	r11,r7[-8]
80002378:	10 9c       	mov	r12,r8
8000237a:	f0 1f 00 0a 	mcall	800023a0 <sd_mmc_spi_send_command+0x4c>
8000237e:	18 98       	mov	r8,r12
80002380:	48 99       	lddpc	r9,800023a4 <sd_mmc_spi_send_command+0x50>
80002382:	b2 88       	st.b	r9[0x0],r8
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002384:	30 1b       	mov	r11,1
80002386:	fe 7c 28 00 	mov	r12,-55296
8000238a:	f0 1f 00 08 	mcall	800023a8 <sd_mmc_spi_send_command+0x54>
  return r1;
8000238e:	48 68       	lddpc	r8,800023a4 <sd_mmc_spi_send_command+0x50>
80002390:	11 88       	ld.ub	r8,r8[0x0]
}
80002392:	10 9c       	mov	r12,r8
80002394:	2f ed       	sub	sp,-8
80002396:	e3 cd 80 80 	ldm	sp++,r7,pc
8000239a:	00 00       	add	r0,r0
8000239c:	80 00       	ld.sh	r0,r0[0x0]
8000239e:	3a 90       	mov	r0,-87
800023a0:	80 00       	ld.sh	r0,r0[0x0]
800023a2:	23 ac       	sub	r12,58
800023a4:	00 00       	add	r0,r0
800023a6:	03 3c       	ld.ub	r12,r1++
800023a8:	80 00       	ld.sh	r0,r0[0x0]
800023aa:	3b 28       	mov	r8,-78

800023ac <sd_mmc_spi_command>:
//! @param  arg       argument of the command
//!
//! @return uint8_t
//!         R1 response (R1 == 0xFF time out error)
uint8_t sd_mmc_spi_command(uint8_t command, uint32_t arg)
{
800023ac:	eb cd 40 80 	pushm	r7,lr
800023b0:	1a 97       	mov	r7,sp
800023b2:	20 3d       	sub	sp,12
800023b4:	18 98       	mov	r8,r12
800023b6:	ef 4b ff f4 	st.w	r7[-12],r11
800023ba:	ef 68 ff f8 	st.b	r7[-8],r8
  uint8_t retry;

  spi_write(SD_MMC_SPI, 0xFF);            // write dummy byte
800023be:	e0 6b 00 ff 	mov	r11,255
800023c2:	fe 7c 28 00 	mov	r12,-55296
800023c6:	f0 1f 00 3b 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  spi_write(SD_MMC_SPI, command | 0x40);  // send command
800023ca:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800023ce:	a7 a8       	sbr	r8,0x6
800023d0:	5c 58       	castu.b	r8
800023d2:	10 9b       	mov	r11,r8
800023d4:	fe 7c 28 00 	mov	r12,-55296
800023d8:	f0 1f 00 36 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  spi_write(SD_MMC_SPI, arg>>24);         // send parameter
800023dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800023e0:	b9 88       	lsr	r8,0x18
800023e2:	5c 88       	casts.h	r8
800023e4:	5c 78       	castu.h	r8
800023e6:	10 9b       	mov	r11,r8
800023e8:	fe 7c 28 00 	mov	r12,-55296
800023ec:	f0 1f 00 31 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  spi_write(SD_MMC_SPI, arg>>16);
800023f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800023f4:	b1 88       	lsr	r8,0x10
800023f6:	5c 88       	casts.h	r8
800023f8:	5c 78       	castu.h	r8
800023fa:	10 9b       	mov	r11,r8
800023fc:	fe 7c 28 00 	mov	r12,-55296
80002400:	f0 1f 00 2c 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  spi_write(SD_MMC_SPI, arg>>8 );
80002404:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002408:	a9 88       	lsr	r8,0x8
8000240a:	5c 88       	casts.h	r8
8000240c:	5c 78       	castu.h	r8
8000240e:	10 9b       	mov	r11,r8
80002410:	fe 7c 28 00 	mov	r12,-55296
80002414:	f0 1f 00 27 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  spi_write(SD_MMC_SPI, arg    );
80002418:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000241c:	5c 88       	casts.h	r8
8000241e:	5c 78       	castu.h	r8
80002420:	10 9b       	mov	r11,r8
80002422:	fe 7c 28 00 	mov	r12,-55296
80002426:	f0 1f 00 23 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  switch(command)
8000242a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000242e:	58 08       	cp.w	r8,0
80002430:	c0 40       	breq	80002438 <sd_mmc_spi_command+0x8c>
80002432:	58 88       	cp.w	r8,8
80002434:	c0 90       	breq	80002446 <sd_mmc_spi_command+0x9a>
80002436:	c0 f8       	rjmp	80002454 <sd_mmc_spi_command+0xa8>
  {
      case MMC_GO_IDLE_STATE:
         spi_write(SD_MMC_SPI, 0x95);
80002438:	e0 6b 00 95 	mov	r11,149
8000243c:	fe 7c 28 00 	mov	r12,-55296
80002440:	f0 1f 00 1c 	mcall	800024b0 <sd_mmc_spi_command+0x104>
         break;
80002444:	c0 e8       	rjmp	80002460 <sd_mmc_spi_command+0xb4>
      case MMC_SEND_IF_COND:
         spi_write(SD_MMC_SPI, 0x87);
80002446:	e0 6b 00 87 	mov	r11,135
8000244a:	fe 7c 28 00 	mov	r12,-55296
8000244e:	f0 1f 00 19 	mcall	800024b0 <sd_mmc_spi_command+0x104>
         break;
80002452:	c0 78       	rjmp	80002460 <sd_mmc_spi_command+0xb4>
      default:
         spi_write(SD_MMC_SPI, 0xff);
80002454:	e0 6b 00 ff 	mov	r11,255
80002458:	fe 7c 28 00 	mov	r12,-55296
8000245c:	f0 1f 00 15 	mcall	800024b0 <sd_mmc_spi_command+0x104>
  }

  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
80002460:	30 08       	mov	r8,0
80002462:	ef 68 ff ff 	st.b	r7[-1],r8
  r1    = 0xFF;
80002466:	49 49       	lddpc	r9,800024b4 <sd_mmc_spi_command+0x108>
80002468:	3f f8       	mov	r8,-1
8000246a:	b2 88       	st.b	r9[0x0],r8
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
8000246c:	c0 d8       	rjmp	80002486 <sd_mmc_spi_command+0xda>
  {
    retry++;
8000246e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002472:	2f f8       	sub	r8,-1
80002474:	ef 68 ff ff 	st.b	r7[-1],r8
    if(retry > 10) break;
80002478:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000247c:	30 a8       	mov	r8,10
8000247e:	f0 09 18 00 	cp.b	r9,r8
80002482:	e0 8b 00 10 	brhi	800024a2 <sd_mmc_spi_command+0xf6>
  // end command
  // wait for response
  // if more than 8 retries, card has timed-out and return the received 0xFF
  retry = 0;
  r1    = 0xFF;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) == 0xFF)
80002486:	e0 6c 00 ff 	mov	r12,255
8000248a:	f0 1f 00 0c 	mcall	800024b8 <sd_mmc_spi_command+0x10c>
8000248e:	18 98       	mov	r8,r12
80002490:	48 99       	lddpc	r9,800024b4 <sd_mmc_spi_command+0x108>
80002492:	b2 88       	st.b	r9[0x0],r8
80002494:	48 88       	lddpc	r8,800024b4 <sd_mmc_spi_command+0x108>
80002496:	11 89       	ld.ub	r9,r8[0x0]
80002498:	3f f8       	mov	r8,-1
8000249a:	f0 09 18 00 	cp.b	r9,r8
8000249e:	ce 80       	breq	8000246e <sd_mmc_spi_command+0xc2>
800024a0:	c0 28       	rjmp	800024a4 <sd_mmc_spi_command+0xf8>
  {
    retry++;
    if(retry > 10) break;
800024a2:	d7 03       	nop
  }
  return r1;
800024a4:	48 48       	lddpc	r8,800024b4 <sd_mmc_spi_command+0x108>
800024a6:	11 88       	ld.ub	r8,r8[0x0]
}
800024a8:	10 9c       	mov	r12,r8
800024aa:	2f dd       	sub	sp,-12
800024ac:	e3 cd 80 80 	ldm	sp++,r7,pc
800024b0:	80 00       	ld.sh	r0,r0[0x0]
800024b2:	3d 32       	mov	r2,-45
800024b4:	00 00       	add	r0,r0
800024b6:	03 3c       	ld.ub	r12,r1++
800024b8:	80 00       	ld.sh	r0,r0[0x0]
800024ba:	24 bc       	sub	r12,75

800024bc <sd_mmc_spi_send_and_read>:
//! @param  data_to_send   byte to send over SPI
//!
//! @return uint8_t
//!   Byte read from the slave
uint8_t sd_mmc_spi_send_and_read(uint8_t data_to_send)
{
800024bc:	eb cd 40 80 	pushm	r7,lr
800024c0:	1a 97       	mov	r7,sp
800024c2:	20 2d       	sub	sp,8
800024c4:	18 98       	mov	r8,r12
800024c6:	ef 68 ff f8 	st.b	r7[-8],r8
   unsigned short data_read;
   spi_write(SD_MMC_SPI, data_to_send);
800024ca:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800024ce:	10 9b       	mov	r11,r8
800024d0:	fe 7c 28 00 	mov	r12,-55296
800024d4:	f0 1f 00 0b 	mcall	80002500 <sd_mmc_spi_send_and_read+0x44>
   if( SPI_ERROR_TIMEOUT == spi_read(SD_MMC_SPI, &data_read) )
800024d8:	ee c8 00 02 	sub	r8,r7,2
800024dc:	10 9b       	mov	r11,r8
800024de:	fe 7c 28 00 	mov	r12,-55296
800024e2:	f0 1f 00 09 	mcall	80002504 <sd_mmc_spi_send_and_read+0x48>
800024e6:	18 98       	mov	r8,r12
800024e8:	58 18       	cp.w	r8,1
800024ea:	c0 41       	brne	800024f2 <sd_mmc_spi_send_and_read+0x36>
     return 0xFF;
800024ec:	e0 68 00 ff 	mov	r8,255
800024f0:	c0 48       	rjmp	800024f8 <sd_mmc_spi_send_and_read+0x3c>
   return data_read;
800024f2:	ef 08 ff fe 	ld.sh	r8,r7[-2]
800024f6:	5c 58       	castu.b	r8
}
800024f8:	10 9c       	mov	r12,r8
800024fa:	2f ed       	sub	sp,-8
800024fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002500:	80 00       	ld.sh	r0,r0[0x0]
80002502:	3d 32       	mov	r2,-45
80002504:	80 00       	ld.sh	r0,r0[0x0]
80002506:	3d 8a       	mov	r10,-40

80002508 <sd_mmc_spi_get_if>:
//!                true
//!                SD_MMC


int sd_mmc_spi_get_if(void)
{
80002508:	eb cd 40 80 	pushm	r7,lr
8000250c:	1a 97       	mov	r7,sp
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
8000250e:	f0 1f 00 31 	mcall	800025d0 <sd_mmc_spi_get_if+0xc8>
80002512:	18 98       	mov	r8,r12
80002514:	ec 18 00 01 	eorl	r8,0x1
80002518:	5c 58       	castu.b	r8
8000251a:	c0 30       	breq	80002520 <sd_mmc_spi_get_if+0x18>
    return SD_FAILURE;
8000251c:	3f f8       	mov	r8,-1
8000251e:	c5 58       	rjmp	800025c8 <sd_mmc_spi_get_if+0xc0>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002520:	30 1b       	mov	r11,1
80002522:	fe 7c 28 00 	mov	r12,-55296
80002526:	f0 1f 00 2c 	mcall	800025d4 <sd_mmc_spi_get_if+0xcc>
  r1 = sd_mmc_spi_command(MMC_SEND_IF_COND, 0x000001AA);
8000252a:	e0 6b 01 aa 	mov	r11,426
8000252e:	30 8c       	mov	r12,8
80002530:	f0 1f 00 2a 	mcall	800025d8 <sd_mmc_spi_get_if+0xd0>
80002534:	18 98       	mov	r8,r12
80002536:	4a a9       	lddpc	r9,800025dc <sd_mmc_spi_get_if+0xd4>
80002538:	b2 88       	st.b	r9[0x0],r8
  // check for valid response
  if((r1 & MMC_R1_ILLEGAL_COM) != 0) {
8000253a:	4a 98       	lddpc	r8,800025dc <sd_mmc_spi_get_if+0xd4>
8000253c:	11 88       	ld.ub	r8,r8[0x0]
8000253e:	e2 18 00 04 	andl	r8,0x4,COH
80002542:	c0 80       	breq	80002552 <sd_mmc_spi_get_if+0x4a>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002544:	30 1b       	mov	r11,1
80002546:	fe 7c 28 00 	mov	r12,-55296
8000254a:	f0 1f 00 26 	mcall	800025e0 <sd_mmc_spi_get_if+0xd8>
    return SD_MMC;
8000254e:	30 08       	mov	r8,0
80002550:	c3 c8       	rjmp	800025c8 <sd_mmc_spi_get_if+0xc0>
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002552:	e0 6c 00 ff 	mov	r12,255
80002556:	f0 1f 00 24 	mcall	800025e4 <sd_mmc_spi_get_if+0xdc>
8000255a:	18 98       	mov	r8,r12
8000255c:	4a 09       	lddpc	r9,800025dc <sd_mmc_spi_get_if+0xd4>
8000255e:	b2 88       	st.b	r9[0x0],r8
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002560:	e0 6c 00 ff 	mov	r12,255
80002564:	f0 1f 00 20 	mcall	800025e4 <sd_mmc_spi_get_if+0xdc>
80002568:	18 98       	mov	r8,r12
8000256a:	49 d9       	lddpc	r9,800025dc <sd_mmc_spi_get_if+0xd4>
8000256c:	b2 88       	st.b	r9[0x0],r8
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000256e:	e0 6c 00 ff 	mov	r12,255
80002572:	f0 1f 00 1d 	mcall	800025e4 <sd_mmc_spi_get_if+0xdc>
80002576:	18 98       	mov	r8,r12
80002578:	49 99       	lddpc	r9,800025dc <sd_mmc_spi_get_if+0xd4>
8000257a:	b2 88       	st.b	r9[0x0],r8
  if((r1 & 0x01) == 0) {
8000257c:	49 88       	lddpc	r8,800025dc <sd_mmc_spi_get_if+0xd4>
8000257e:	11 88       	ld.ub	r8,r8[0x0]
80002580:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002584:	c0 81       	brne	80002594 <sd_mmc_spi_get_if+0x8c>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002586:	30 1b       	mov	r11,1
80002588:	fe 7c 28 00 	mov	r12,-55296
8000258c:	f0 1f 00 15 	mcall	800025e0 <sd_mmc_spi_get_if+0xd8>
    return SD_FAILURE;
80002590:	3f f8       	mov	r8,-1
80002592:	c1 b8       	rjmp	800025c8 <sd_mmc_spi_get_if+0xc0>
  }
  r1 = sd_mmc_spi_send_and_read(0xFF);
80002594:	e0 6c 00 ff 	mov	r12,255
80002598:	f0 1f 00 13 	mcall	800025e4 <sd_mmc_spi_get_if+0xdc>
8000259c:	18 98       	mov	r8,r12
8000259e:	49 09       	lddpc	r9,800025dc <sd_mmc_spi_get_if+0xd4>
800025a0:	b2 88       	st.b	r9[0x0],r8
  if(r1 != 0xaa) {
800025a2:	48 f8       	lddpc	r8,800025dc <sd_mmc_spi_get_if+0xd4>
800025a4:	11 89       	ld.ub	r9,r8[0x0]
800025a6:	3a a8       	mov	r8,-86
800025a8:	f0 09 18 00 	cp.b	r9,r8
800025ac:	c0 80       	breq	800025bc <sd_mmc_spi_get_if+0xb4>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025ae:	30 1b       	mov	r11,1
800025b0:	fe 7c 28 00 	mov	r12,-55296
800025b4:	f0 1f 00 0b 	mcall	800025e0 <sd_mmc_spi_get_if+0xd8>
    return SD_FAILURE; /* wrong test pattern */
800025b8:	3f f8       	mov	r8,-1
800025ba:	c0 78       	rjmp	800025c8 <sd_mmc_spi_get_if+0xc0>
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800025bc:	30 1b       	mov	r11,1
800025be:	fe 7c 28 00 	mov	r12,-55296
800025c2:	f0 1f 00 08 	mcall	800025e0 <sd_mmc_spi_get_if+0xd8>
  return true;
800025c6:	30 18       	mov	r8,1
}
800025c8:	10 9c       	mov	r12,r8
800025ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800025ce:	00 00       	add	r0,r0
800025d0:	80 00       	ld.sh	r0,r0[0x0]
800025d2:	29 d8       	sub	r8,-99
800025d4:	80 00       	ld.sh	r0,r0[0x0]
800025d6:	3a 90       	mov	r0,-87
800025d8:	80 00       	ld.sh	r0,r0[0x0]
800025da:	23 ac       	sub	r12,58
800025dc:	00 00       	add	r0,r0
800025de:	03 3c       	ld.ub	r12,r1++
800025e0:	80 00       	ld.sh	r0,r0[0x0]
800025e2:	3b 28       	mov	r8,-78
800025e4:	80 00       	ld.sh	r0,r0[0x0]
800025e6:	24 bc       	sub	r12,75

800025e8 <sd_mmc_spi_check_hc>:
//!           SD_CARD      Detected card is SD
//!           ERROR


int sd_mmc_spi_check_hc(void)
{
800025e8:	eb cd 40 80 	pushm	r7,lr
800025ec:	1a 97       	mov	r7,sp
800025ee:	20 1d       	sub	sp,4
  unsigned char hc_bit;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800025f0:	f0 1f 00 27 	mcall	8000268c <sd_mmc_spi_check_hc+0xa4>
800025f4:	18 98       	mov	r8,r12
800025f6:	ec 18 00 01 	eorl	r8,0x1
800025fa:	5c 58       	castu.b	r8
800025fc:	c0 30       	breq	80002602 <sd_mmc_spi_check_hc+0x1a>
    return SD_FAILURE;
800025fe:	3f f8       	mov	r8,-1
80002600:	c4 18       	rjmp	80002682 <sd_mmc_spi_check_hc+0x9a>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
80002602:	30 1b       	mov	r11,1
80002604:	fe 7c 28 00 	mov	r12,-55296
80002608:	f0 1f 00 22 	mcall	80002690 <sd_mmc_spi_check_hc+0xa8>
  r1 = sd_mmc_spi_command(SD_READ_OCR, 0);
8000260c:	30 0b       	mov	r11,0
8000260e:	33 ac       	mov	r12,58
80002610:	f0 1f 00 21 	mcall	80002694 <sd_mmc_spi_check_hc+0xac>
80002614:	18 98       	mov	r8,r12
80002616:	4a 19       	lddpc	r9,80002698 <sd_mmc_spi_check_hc+0xb0>
80002618:	b2 88       	st.b	r9[0x0],r8
  // check for valid response
  if(r1 != 0) {
8000261a:	4a 08       	lddpc	r8,80002698 <sd_mmc_spi_check_hc+0xb0>
8000261c:	11 88       	ld.ub	r8,r8[0x0]
8000261e:	58 08       	cp.w	r8,0
80002620:	c0 80       	breq	80002630 <sd_mmc_spi_check_hc+0x48>
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002622:	30 1b       	mov	r11,1
80002624:	fe 7c 28 00 	mov	r12,-55296
80002628:	f0 1f 00 1d 	mcall	8000269c <sd_mmc_spi_check_hc+0xb4>
    return SD_FAILURE;
8000262c:	3f f8       	mov	r8,-1
8000262e:	c2 a8       	rjmp	80002682 <sd_mmc_spi_check_hc+0x9a>
  }
  hc_bit = sd_mmc_spi_send_and_read(0xFF);
80002630:	e0 6c 00 ff 	mov	r12,255
80002634:	f0 1f 00 1b 	mcall	800026a0 <sd_mmc_spi_check_hc+0xb8>
80002638:	18 98       	mov	r8,r12
8000263a:	ef 68 ff ff 	st.b	r7[-1],r8
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000263e:	e0 6c 00 ff 	mov	r12,255
80002642:	f0 1f 00 18 	mcall	800026a0 <sd_mmc_spi_check_hc+0xb8>
80002646:	18 98       	mov	r8,r12
80002648:	49 49       	lddpc	r9,80002698 <sd_mmc_spi_check_hc+0xb0>
8000264a:	b2 88       	st.b	r9[0x0],r8
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000264c:	e0 6c 00 ff 	mov	r12,255
80002650:	f0 1f 00 14 	mcall	800026a0 <sd_mmc_spi_check_hc+0xb8>
80002654:	18 98       	mov	r8,r12
80002656:	49 19       	lddpc	r9,80002698 <sd_mmc_spi_check_hc+0xb0>
80002658:	b2 88       	st.b	r9[0x0],r8
  r1 = sd_mmc_spi_send_and_read(0xFF);
8000265a:	e0 6c 00 ff 	mov	r12,255
8000265e:	f0 1f 00 11 	mcall	800026a0 <sd_mmc_spi_check_hc+0xb8>
80002662:	18 98       	mov	r8,r12
80002664:	48 d9       	lddpc	r9,80002698 <sd_mmc_spi_check_hc+0xb0>
80002666:	b2 88       	st.b	r9[0x0],r8
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80002668:	30 1b       	mov	r11,1
8000266a:	fe 7c 28 00 	mov	r12,-55296
8000266e:	f0 1f 00 0c 	mcall	8000269c <sd_mmc_spi_check_hc+0xb4>
  if(hc_bit & 0x40) {
80002672:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002676:	e2 18 00 40 	andl	r8,0x40,COH
8000267a:	c0 30       	breq	80002680 <sd_mmc_spi_check_hc+0x98>
      return SDHC_CARD;
8000267c:	30 18       	mov	r8,1
8000267e:	c0 28       	rjmp	80002682 <sd_mmc_spi_check_hc+0x9a>
  }
  return 0;
80002680:	30 08       	mov	r8,0
}
80002682:	10 9c       	mov	r12,r8
80002684:	2f fd       	sub	sp,-4
80002686:	e3 cd 80 80 	ldm	sp++,r7,pc
8000268a:	00 00       	add	r0,r0
8000268c:	80 00       	ld.sh	r0,r0[0x0]
8000268e:	29 d8       	sub	r8,-99
80002690:	80 00       	ld.sh	r0,r0[0x0]
80002692:	3a 90       	mov	r0,-87
80002694:	80 00       	ld.sh	r0,r0[0x0]
80002696:	23 ac       	sub	r12,58
80002698:	00 00       	add	r0,r0
8000269a:	03 3c       	ld.ub	r12,r1++
8000269c:	80 00       	ld.sh	r0,r0[0x0]
8000269e:	3b 28       	mov	r8,-78
800026a0:	80 00       	ld.sh	r0,r0[0x0]
800026a2:	24 bc       	sub	r12,75

800026a4 <sd_mmc_spi_get_csd>:
//! @param  buffer to fill
//!
//! @return bit
//!         true / false
bool sd_mmc_spi_get_csd(uint8_t *buffer)
{
800026a4:	eb cd 40 80 	pushm	r7,lr
800026a8:	1a 97       	mov	r7,sp
800026aa:	20 2d       	sub	sp,8
800026ac:	ef 4c ff f8 	st.w	r7[-8],r12
uint8_t retry;
unsigned short data_read;
  // wait for MMC not busy
  if (false == sd_mmc_spi_wait_not_busy())
800026b0:	f0 1f 00 45 	mcall	800027c4 <sd_mmc_spi_get_csd+0x120>
800026b4:	18 98       	mov	r8,r12
800026b6:	ec 18 00 01 	eorl	r8,0x1
800026ba:	5c 58       	castu.b	r8
800026bc:	c0 30       	breq	800026c2 <sd_mmc_spi_get_csd+0x1e>
    return false;
800026be:	30 08       	mov	r8,0
800026c0:	c7 d8       	rjmp	800027ba <sd_mmc_spi_get_csd+0x116>

  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);    // select SD_MMC_SPI
800026c2:	30 1b       	mov	r11,1
800026c4:	fe 7c 28 00 	mov	r12,-55296
800026c8:	f0 1f 00 40 	mcall	800027c8 <sd_mmc_spi_get_csd+0x124>
  // issue command
  r1 = sd_mmc_spi_command(MMC_SEND_CSD, 0);
800026cc:	30 0b       	mov	r11,0
800026ce:	30 9c       	mov	r12,9
800026d0:	f0 1f 00 3f 	mcall	800027cc <sd_mmc_spi_get_csd+0x128>
800026d4:	18 98       	mov	r8,r12
800026d6:	4b f9       	lddpc	r9,800027d0 <sd_mmc_spi_get_csd+0x12c>
800026d8:	b2 88       	st.b	r9[0x0],r8
  // check for valid response
  if(r1 != 0x00)
800026da:	4b e8       	lddpc	r8,800027d0 <sd_mmc_spi_get_csd+0x12c>
800026dc:	11 88       	ld.ub	r8,r8[0x0]
800026de:	58 08       	cp.w	r8,0
800026e0:	c0 b0       	breq	800026f6 <sd_mmc_spi_get_csd+0x52>
  {
    spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800026e2:	30 1b       	mov	r11,1
800026e4:	fe 7c 28 00 	mov	r12,-55296
800026e8:	f0 1f 00 3b 	mcall	800027d4 <sd_mmc_spi_get_csd+0x130>
    sd_mmc_spi_init_done = false;
800026ec:	4b b9       	lddpc	r9,800027d8 <sd_mmc_spi_get_csd+0x134>
800026ee:	30 08       	mov	r8,0
800026f0:	b2 88       	st.b	r9[0x0],r8
    return false;
800026f2:	30 08       	mov	r8,0
800026f4:	c6 38       	rjmp	800027ba <sd_mmc_spi_get_csd+0x116>
  }
  // wait for block start
  retry = 0;
800026f6:	30 08       	mov	r8,0
800026f8:	ef 68 ff ff 	st.b	r7[-1],r8
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
800026fc:	c1 48       	rjmp	80002724 <sd_mmc_spi_get_csd+0x80>
  {
    if (retry > 8)
800026fe:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002702:	30 88       	mov	r8,8
80002704:	f0 09 18 00 	cp.b	r9,r8
80002708:	e0 88 00 09 	brls	8000271a <sd_mmc_spi_get_csd+0x76>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
8000270c:	30 1b       	mov	r11,1
8000270e:	fe 7c 28 00 	mov	r12,-55296
80002712:	f0 1f 00 31 	mcall	800027d4 <sd_mmc_spi_get_csd+0x130>
      return false;
80002716:	30 08       	mov	r8,0
80002718:	c5 18       	rjmp	800027ba <sd_mmc_spi_get_csd+0x116>
    }
    retry++;
8000271a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000271e:	2f f8       	sub	r8,-1
80002720:	ef 68 ff ff 	st.b	r7[-1],r8
    sd_mmc_spi_init_done = false;
    return false;
  }
  // wait for block start
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != MMC_STARTBLOCK_READ)
80002724:	e0 6c 00 ff 	mov	r12,255
80002728:	f0 1f 00 2d 	mcall	800027dc <sd_mmc_spi_get_csd+0x138>
8000272c:	18 98       	mov	r8,r12
8000272e:	4a 99       	lddpc	r9,800027d0 <sd_mmc_spi_get_csd+0x12c>
80002730:	b2 88       	st.b	r9[0x0],r8
80002732:	4a 88       	lddpc	r8,800027d0 <sd_mmc_spi_get_csd+0x12c>
80002734:	11 89       	ld.ub	r9,r8[0x0]
80002736:	3f e8       	mov	r8,-2
80002738:	f0 09 18 00 	cp.b	r9,r8
8000273c:	ce 11       	brne	800026fe <sd_mmc_spi_get_csd+0x5a>
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
8000273e:	30 08       	mov	r8,0
80002740:	ef 68 ff ff 	st.b	r7[-1],r8
80002744:	c1 c8       	rjmp	8000277c <sd_mmc_spi_get_csd+0xd8>
  {
   spi_write(SD_MMC_SPI,0xFF);
80002746:	e0 6b 00 ff 	mov	r11,255
8000274a:	fe 7c 28 00 	mov	r12,-55296
8000274e:	f0 1f 00 25 	mcall	800027e0 <sd_mmc_spi_get_csd+0x13c>
   spi_read(SD_MMC_SPI,&data_read);
80002752:	ee c8 00 04 	sub	r8,r7,4
80002756:	10 9b       	mov	r11,r8
80002758:	fe 7c 28 00 	mov	r12,-55296
8000275c:	f0 1f 00 22 	mcall	800027e4 <sd_mmc_spi_get_csd+0x140>
    buffer[retry] = data_read;
80002760:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002764:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002768:	10 09       	add	r9,r8
8000276a:	ef 08 ff fc 	ld.sh	r8,r7[-4]
8000276e:	5c 58       	castu.b	r8
80002770:	b2 88       	st.b	r9[0x0],r8
      return false;
    }
    retry++;
  }
  // store valid data block
  for (retry = 0; retry <16; retry++)
80002772:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80002776:	2f f8       	sub	r8,-1
80002778:	ef 68 ff ff 	st.b	r7[-1],r8
8000277c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80002780:	30 f8       	mov	r8,15
80002782:	f0 09 18 00 	cp.b	r9,r8
80002786:	fe 98 ff e0 	brls	80002746 <sd_mmc_spi_get_csd+0xa2>
  {
   spi_write(SD_MMC_SPI,0xFF);
   spi_read(SD_MMC_SPI,&data_read);
    buffer[retry] = data_read;
  }
   spi_write(SD_MMC_SPI,0xFF);   // load CRC (not used)
8000278a:	e0 6b 00 ff 	mov	r11,255
8000278e:	fe 7c 28 00 	mov	r12,-55296
80002792:	f0 1f 00 14 	mcall	800027e0 <sd_mmc_spi_get_csd+0x13c>
   spi_write(SD_MMC_SPI,0xFF);
80002796:	e0 6b 00 ff 	mov	r11,255
8000279a:	fe 7c 28 00 	mov	r12,-55296
8000279e:	f0 1f 00 11 	mcall	800027e0 <sd_mmc_spi_get_csd+0x13c>
   spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
800027a2:	e0 6b 00 ff 	mov	r11,255
800027a6:	fe 7c 28 00 	mov	r12,-55296
800027aa:	f0 1f 00 0e 	mcall	800027e0 <sd_mmc_spi_get_csd+0x13c>
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
800027ae:	30 1b       	mov	r11,1
800027b0:	fe 7c 28 00 	mov	r12,-55296
800027b4:	f0 1f 00 08 	mcall	800027d4 <sd_mmc_spi_get_csd+0x130>
  return true;
800027b8:	30 18       	mov	r8,1
}
800027ba:	10 9c       	mov	r12,r8
800027bc:	2f ed       	sub	sp,-8
800027be:	e3 cd 80 80 	ldm	sp++,r7,pc
800027c2:	00 00       	add	r0,r0
800027c4:	80 00       	ld.sh	r0,r0[0x0]
800027c6:	29 d8       	sub	r8,-99
800027c8:	80 00       	ld.sh	r0,r0[0x0]
800027ca:	3a 90       	mov	r0,-87
800027cc:	80 00       	ld.sh	r0,r0[0x0]
800027ce:	23 ac       	sub	r12,58
800027d0:	00 00       	add	r0,r0
800027d2:	03 3c       	ld.ub	r12,r1++
800027d4:	80 00       	ld.sh	r0,r0[0x0]
800027d6:	3b 28       	mov	r8,-78
800027d8:	00 00       	add	r0,r0
800027da:	00 24       	rsub	r4,r0
800027dc:	80 00       	ld.sh	r0,r0[0x0]
800027de:	24 bc       	sub	r12,75
800027e0:	80 00       	ld.sh	r0,r0[0x0]
800027e2:	3d 32       	mov	r2,-45
800027e4:	80 00       	ld.sh	r0,r0[0x0]
800027e6:	3d 8a       	mov	r10,-40

800027e8 <sd_mmc_spi_get_capacity>:
//!         [39]    == data[11] && 0x80
//!
//! @return bit
//!         true
void sd_mmc_spi_get_capacity(void)
{
800027e8:	eb cd 40 8f 	pushm	r0-r3,r7,lr
800027ec:	1a 97       	mov	r7,sp
800027ee:	20 2d       	sub	sp,8
  uint8_t  read_bl_len;
  uint8_t  erase_grp_size;
  uint8_t  erase_grp_mult;

  // extract variables from CSD array
  read_bl_len = csd[5] & 0x0F;
800027f0:	4f 4c       	lddpc	r12,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
800027f2:	19 dc       	ld.ub	r12,r12[0x5]
800027f4:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
800027f8:	ef 6c ff fd 	st.b	r7[-3],r12
  if (card_type == SD_CARD_2_SDHC) {
800027fc:	4f 2c       	lddpc	r12,800029c4 <sd_mmc_spi_get_capacity+0x1dc>
800027fe:	19 8e       	ld.ub	lr,r12[0x0]
80002800:	30 3c       	mov	r12,3
80002802:	f8 0e 18 00 	cp.b	lr,r12
80002806:	c4 71       	brne	80002894 <sd_mmc_spi_get_capacity+0xac>
    c_size = ((csd[7] & 0x3F) << 16) | (csd[8] << 8) | csd[9];
80002808:	4e ec       	lddpc	r12,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
8000280a:	19 fc       	ld.ub	r12,r12[0x7]
8000280c:	f9 dc c0 06 	bfextu	r12,r12,0x0,0x6
80002810:	f8 0e 15 10 	lsl	lr,r12,0x10
80002814:	4e bc       	lddpc	r12,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002816:	f9 3c 00 08 	ld.ub	r12,r12[8]
8000281a:	a9 6c       	lsl	r12,0x8
8000281c:	18 4e       	or	lr,r12
8000281e:	4e 9c       	lddpc	r12,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002820:	f9 3c 00 09 	ld.ub	r12,r12[9]
80002824:	fd ec 10 0c 	or	r12,lr,r12
80002828:	ef 4c ff f8 	st.w	r7[-8],r12
    ++c_size;
8000282c:	ee fc ff f8 	ld.w	r12,r7[-8]
80002830:	2f fc       	sub	r12,-1
80002832:	ef 4c ff f8 	st.w	r7[-8],r12
    capacity = (uint64_t)c_size << 19;
80002836:	ee f2 ff f8 	ld.w	r2,r7[-8]
8000283a:	30 03       	mov	r3,0
8000283c:	e4 0c 16 0d 	lsr	r12,r2,0xd
80002840:	e6 0b 15 13 	lsl	r11,r3,0x13
80002844:	f9 eb 10 0b 	or	r11,r12,r11
80002848:	e4 0a 15 13 	lsl	r10,r2,0x13
8000284c:	4d fc       	lddpc	r12,800029c8 <sd_mmc_spi_get_capacity+0x1e0>
8000284e:	f8 eb 00 00 	st.d	r12[0],r10
    capacity_mult = (c_size >> 13) & 0x01FF;
80002852:	ee fa ff f8 	ld.w	r10,r7[-8]
80002856:	ad 9a       	lsr	r10,0xd
80002858:	5c 8a       	casts.h	r10
8000285a:	5c 8a       	casts.h	r10
8000285c:	f5 da c0 09 	bfextu	r10,r10,0x0,0x9
80002860:	4d bb       	lddpc	r11,800029cc <sd_mmc_spi_get_capacity+0x1e4>
80002862:	b6 0a       	st.h	r11[0x0],r10
    sd_mmc_spi_last_block_address = (capacity >> 9) + (capacity_mult << 23) - 1;
80002864:	4d 9a       	lddpc	r10,800029c8 <sd_mmc_spi_get_capacity+0x1e0>
80002866:	f4 ea 00 00 	ld.d	r10,r10[0]
8000286a:	f6 0c 15 17 	lsl	r12,r11,0x17
8000286e:	f4 08 16 09 	lsr	r8,r10,0x9
80002872:	f9 e8 10 08 	or	r8,r12,r8
80002876:	f6 09 16 09 	lsr	r9,r11,0x9
8000287a:	10 99       	mov	r9,r8
8000287c:	4d 48       	lddpc	r8,800029cc <sd_mmc_spi_get_capacity+0x1e4>
8000287e:	90 08       	ld.sh	r8,r8[0x0]
80002880:	5c 88       	casts.h	r8
80002882:	5c 78       	castu.h	r8
80002884:	b7 78       	lsl	r8,0x17
80002886:	f2 08 00 08 	add	r8,r9,r8
8000288a:	f0 c9 00 01 	sub	r9,r8,1
8000288e:	4d 18       	lddpc	r8,800029d0 <sd_mmc_spi_get_capacity+0x1e8>
80002890:	91 09       	st.w	r8[0x0],r9
80002892:	c5 28       	rjmp	80002936 <sd_mmc_spi_get_capacity+0x14e>
  } else {
    c_size      = ((csd[6] & 0x03) << 10) + (csd[7] << 2) + ((csd[8] & 0xC0) >> 6);
80002894:	4c b8       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002896:	11 e8       	ld.ub	r8,r8[0x6]
80002898:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000289c:	f0 09 15 0a 	lsl	r9,r8,0xa
800028a0:	4c 88       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
800028a2:	11 f8       	ld.ub	r8,r8[0x7]
800028a4:	a3 68       	lsl	r8,0x2
800028a6:	10 09       	add	r9,r8
800028a8:	4c 68       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
800028aa:	f1 38 00 08 	ld.ub	r8,r8[8]
800028ae:	a7 88       	lsr	r8,0x6
800028b0:	5c 58       	castu.b	r8
800028b2:	f2 08 00 08 	add	r8,r9,r8
800028b6:	ef 48 ff f8 	st.w	r7[-8],r8
    c_size_mult = ((csd[9] & 0x03) << 1) + ((csd[10] & 0x80) >> 7);
800028ba:	4c 28       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
800028bc:	f1 38 00 09 	ld.ub	r8,r8[9]
800028c0:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
800028c4:	a1 78       	lsl	r8,0x1
800028c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800028ca:	4b e8       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
800028cc:	f1 38 00 0a 	ld.ub	r8,r8[10]
800028d0:	a7 98       	lsr	r8,0x7
800028d2:	5c 58       	castu.b	r8
800028d4:	f2 08 00 08 	add	r8,r9,r8
800028d8:	ef 68 ff fc 	st.b	r7[-4],r8
    sd_mmc_spi_last_block_address = ((uint32_t)(c_size + 1) * (uint32_t)((1 << (c_size_mult + 2)))) - 1;
800028dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028e0:	f0 c9 ff ff 	sub	r9,r8,-1
800028e4:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800028e8:	2f e8       	sub	r8,-2
800028ea:	f2 08 09 48 	lsl	r8,r9,r8
800028ee:	f0 c9 00 01 	sub	r9,r8,1
800028f2:	4b 88       	lddpc	r8,800029d0 <sd_mmc_spi_get_capacity+0x1e8>
800028f4:	91 09       	st.w	r8[0x0],r9
    capacity = (1 << read_bl_len) * (sd_mmc_spi_last_block_address + 1);
800028f6:	4b 78       	lddpc	r8,800029d0 <sd_mmc_spi_get_capacity+0x1e8>
800028f8:	70 08       	ld.w	r8,r8[0x0]
800028fa:	f0 c9 ff ff 	sub	r9,r8,-1
800028fe:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80002902:	f2 08 09 48 	lsl	r8,r9,r8
80002906:	10 90       	mov	r0,r8
80002908:	30 01       	mov	r1,0
8000290a:	4b 08       	lddpc	r8,800029c8 <sd_mmc_spi_get_capacity+0x1e0>
8000290c:	f0 e1 00 00 	st.d	r8[0],r0
    capacity_mult = 0;
80002910:	4a f9       	lddpc	r9,800029cc <sd_mmc_spi_get_capacity+0x1e4>
80002912:	30 08       	mov	r8,0
80002914:	b2 08       	st.h	r9[0x0],r8
    if (read_bl_len > 9) {  // 9 means 2^9 = 512b
80002916:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000291a:	30 98       	mov	r8,9
8000291c:	f0 09 18 00 	cp.b	r9,r8
80002920:	e0 88 00 0b 	brls	80002936 <sd_mmc_spi_get_capacity+0x14e>
      sd_mmc_spi_last_block_address <<= (read_bl_len - 9);
80002924:	4a b8       	lddpc	r8,800029d0 <sd_mmc_spi_get_capacity+0x1e8>
80002926:	70 09       	ld.w	r9,r8[0x0]
80002928:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000292c:	20 98       	sub	r8,9
8000292e:	f2 08 09 49 	lsl	r9,r9,r8
80002932:	4a 88       	lddpc	r8,800029d0 <sd_mmc_spi_get_capacity+0x1e8>
80002934:	91 09       	st.w	r8[0x0],r9
    }
  }
  if (card_type == MMC_CARD)
80002936:	4a 48       	lddpc	r8,800029c4 <sd_mmc_spi_get_capacity+0x1dc>
80002938:	11 88       	ld.ub	r8,r8[0x0]
8000293a:	58 08       	cp.w	r8,0
8000293c:	c1 c1       	brne	80002974 <sd_mmc_spi_get_capacity+0x18c>
  {
    erase_grp_size = ((csd[10] & 0x7C) >> 2);
8000293e:	4a 18       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002940:	f1 38 00 0a 	ld.ub	r8,r8[10]
80002944:	e2 18 00 7c 	andl	r8,0x7c,COH
80002948:	a3 48       	asr	r8,0x2
8000294a:	ef 68 ff fe 	st.b	r7[-2],r8
    erase_grp_mult = ((csd[10] & 0x03) << 3) | ((csd[11] & 0xE0) >> 5);
8000294e:	49 d8       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002950:	f1 38 00 0a 	ld.ub	r8,r8[10]
80002954:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80002958:	a3 78       	lsl	r8,0x3
8000295a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000295e:	49 98       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002960:	f1 38 00 0b 	ld.ub	r8,r8[11]
80002964:	a5 98       	lsr	r8,0x5
80002966:	5c 58       	castu.b	r8
80002968:	f3 e8 10 08 	or	r8,r9,r8
8000296c:	5c 58       	castu.b	r8
8000296e:	ef 68 ff ff 	st.b	r7[-1],r8
80002972:	c1 58       	rjmp	8000299c <sd_mmc_spi_get_capacity+0x1b4>
  }
  else
  {
    erase_grp_size = ((csd[10] & 0x3F) << 1) + ((csd[11] & 0x80) >> 7);
80002974:	49 38       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002976:	f1 38 00 0a 	ld.ub	r8,r8[10]
8000297a:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
8000297e:	a1 78       	lsl	r8,0x1
80002980:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002984:	48 f8       	lddpc	r8,800029c0 <sd_mmc_spi_get_capacity+0x1d8>
80002986:	f1 38 00 0b 	ld.ub	r8,r8[11]
8000298a:	a7 98       	lsr	r8,0x7
8000298c:	5c 58       	castu.b	r8
8000298e:	f2 08 00 08 	add	r8,r9,r8
80002992:	ef 68 ff fe 	st.b	r7[-2],r8
    erase_grp_mult = 0;
80002996:	30 08       	mov	r8,0
80002998:	ef 68 ff ff 	st.b	r7[-1],r8
  }
  erase_group_size = (erase_grp_size + 1) * (erase_grp_mult + 1);
8000299c:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800029a0:	2f f8       	sub	r8,-1
800029a2:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800029a6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800029aa:	2f f8       	sub	r8,-1
800029ac:	5c 88       	casts.h	r8
800029ae:	f2 08 02 48 	mul	r8,r9,r8
800029b2:	5c 88       	casts.h	r8
800029b4:	48 89       	lddpc	r9,800029d4 <sd_mmc_spi_get_capacity+0x1ec>
800029b6:	b2 08       	st.h	r9[0x0],r8
}
800029b8:	2f ed       	sub	sp,-8
800029ba:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
800029be:	00 00       	add	r0,r0
800029c0:	00 00       	add	r0,r0
800029c2:	03 2c       	ld.uh	r12,r1++
800029c4:	00 00       	add	r0,r0
800029c6:	03 2a       	ld.uh	r10,r1++
800029c8:	00 00       	add	r0,r0
800029ca:	03 18       	ld.sh	r8,r1++
800029cc:	00 00       	add	r0,r0
800029ce:	03 20       	ld.uh	r0,r1++
800029d0:	00 00       	add	r0,r0
800029d2:	03 24       	ld.uh	r4,r1++
800029d4:	00 00       	add	r0,r0
800029d6:	03 22       	ld.uh	r2,r1++

800029d8 <sd_mmc_spi_wait_not_busy>:
//! @brief This function waits until the SD/MMC is not busy.
//!
//! @return bit
//!          true when card is not busy
bool sd_mmc_spi_wait_not_busy(void)
{
800029d8:	eb cd 40 80 	pushm	r7,lr
800029dc:	1a 97       	mov	r7,sp
800029de:	20 1d       	sub	sp,4
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
800029e0:	30 1b       	mov	r11,1
800029e2:	fe 7c 28 00 	mov	r12,-55296
800029e6:	f0 1f 00 18 	mcall	80002a44 <sd_mmc_spi_wait_not_busy+0x6c>
  retry = 0;
800029ea:	30 08       	mov	r8,0
800029ec:	ef 48 ff fc 	st.w	r7[-4],r8
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
800029f0:	c1 28       	rjmp	80002a14 <sd_mmc_spi_wait_not_busy+0x3c>
  {
    retry++;
800029f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800029f6:	2f f8       	sub	r8,-1
800029f8:	ef 48 ff fc 	st.w	r7[-4],r8
    if (retry == 200000)
800029fc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a00:	e2 58 0d 40 	cp.w	r8,200000
80002a04:	c0 81       	brne	80002a14 <sd_mmc_spi_wait_not_busy+0x3c>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002a06:	30 1b       	mov	r11,1
80002a08:	fe 7c 28 00 	mov	r12,-55296
80002a0c:	f0 1f 00 0f 	mcall	80002a48 <sd_mmc_spi_wait_not_busy+0x70>
      return false;
80002a10:	30 08       	mov	r8,0
80002a12:	c1 48       	rjmp	80002a3a <sd_mmc_spi_wait_not_busy+0x62>
  uint32_t retry;

  // Select the SD_MMC memory gl_ptr_mem points to
  spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
  retry = 0;
  while((r1 = sd_mmc_spi_send_and_read(0xFF)) != 0xFF)
80002a14:	e0 6c 00 ff 	mov	r12,255
80002a18:	f0 1f 00 0d 	mcall	80002a4c <sd_mmc_spi_wait_not_busy+0x74>
80002a1c:	18 98       	mov	r8,r12
80002a1e:	48 d9       	lddpc	r9,80002a50 <sd_mmc_spi_wait_not_busy+0x78>
80002a20:	b2 88       	st.b	r9[0x0],r8
80002a22:	48 c8       	lddpc	r8,80002a50 <sd_mmc_spi_wait_not_busy+0x78>
80002a24:	11 89       	ld.ub	r9,r8[0x0]
80002a26:	3f f8       	mov	r8,-1
80002a28:	f0 09 18 00 	cp.b	r9,r8
80002a2c:	ce 31       	brne	800029f2 <sd_mmc_spi_wait_not_busy+0x1a>
    {
      spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
      return false;
    }
  }
  spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80002a2e:	30 1b       	mov	r11,1
80002a30:	fe 7c 28 00 	mov	r12,-55296
80002a34:	f0 1f 00 05 	mcall	80002a48 <sd_mmc_spi_wait_not_busy+0x70>
  return true;
80002a38:	30 18       	mov	r8,1
}
80002a3a:	10 9c       	mov	r12,r8
80002a3c:	2f fd       	sub	sp,-4
80002a3e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a42:	00 00       	add	r0,r0
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	3a 90       	mov	r0,-87
80002a48:	80 00       	ld.sh	r0,r0[0x0]
80002a4a:	3b 28       	mov	r8,-78
80002a4c:	80 00       	ld.sh	r0,r0[0x0]
80002a4e:	24 bc       	sub	r12,75
80002a50:	00 00       	add	r0,r0
80002a52:	03 3c       	ld.ub	r12,r1++

80002a54 <sd_mmc_spi_check_presence>:
//!
//! @return bit
//!   The memory is present (true)
//!   The memory does not respond (disconnected) (false)
bool sd_mmc_spi_check_presence(void)
{
80002a54:	eb cd 40 80 	pushm	r7,lr
80002a58:	1a 97       	mov	r7,sp
80002a5a:	20 1d       	sub	sp,4
  uint16_t retry;

  retry = 0;
80002a5c:	30 08       	mov	r8,0
80002a5e:	ef 58 ff fe 	st.h	r7[-2],r8
  if (sd_mmc_spi_init_done == false)
80002a62:	4a 08       	lddpc	r8,80002ae0 <sd_mmc_spi_check_presence+0x8c>
80002a64:	11 88       	ld.ub	r8,r8[0x0]
80002a66:	ec 18 00 01 	eorl	r8,0x1
80002a6a:	5c 58       	castu.b	r8
80002a6c:	c2 50       	breq	80002ab6 <sd_mmc_spi_check_presence+0x62>
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002a6e:	c1 58       	rjmp	80002a98 <sd_mmc_spi_check_presence+0x44>
    {
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
80002a70:	e0 6b 00 ff 	mov	r11,255
80002a74:	fe 7c 28 00 	mov	r12,-55296
80002a78:	f0 1f 00 1b 	mcall	80002ae4 <sd_mmc_spi_check_presence+0x90>
      retry++;
80002a7c:	ef 08 ff fe 	ld.sh	r8,r7[-2]
80002a80:	2f f8       	sub	r8,-1
80002a82:	ef 58 ff fe 	st.h	r7[-2],r8
      if (retry > 10)
80002a86:	ef 09 ff fe 	ld.sh	r9,r7[-2]
80002a8a:	30 a8       	mov	r8,10
80002a8c:	f0 09 19 00 	cp.h	r9,r8
80002a90:	e0 88 00 04 	brls	80002a98 <sd_mmc_spi_check_presence+0x44>
        return false;
80002a94:	30 08       	mov	r8,0
80002a96:	c2 18       	rjmp	80002ad8 <sd_mmc_spi_check_presence+0x84>
  retry = 0;
  if (sd_mmc_spi_init_done == false)
  {
    // If memory is not initialized, try to initialize it (CMD0)
    // If no valid response, there is no card
    while ((r1 = sd_mmc_spi_send_command(MMC_GO_IDLE_STATE, 0)) != 0x01)
80002a98:	30 0b       	mov	r11,0
80002a9a:	30 0c       	mov	r12,0
80002a9c:	f0 1f 00 13 	mcall	80002ae8 <sd_mmc_spi_check_presence+0x94>
80002aa0:	18 98       	mov	r8,r12
80002aa2:	49 39       	lddpc	r9,80002aec <sd_mmc_spi_check_presence+0x98>
80002aa4:	b2 88       	st.b	r9[0x0],r8
80002aa6:	49 28       	lddpc	r8,80002aec <sd_mmc_spi_check_presence+0x98>
80002aa8:	11 89       	ld.ub	r9,r8[0x0]
80002aaa:	30 18       	mov	r8,1
80002aac:	f0 09 18 00 	cp.b	r9,r8
80002ab0:	ce 01       	brne	80002a70 <sd_mmc_spi_check_presence+0x1c>
      spi_write(SD_MMC_SPI,0xFF);            // write dummy byte
      retry++;
      if (retry > 10)
        return false;
    }
    return true;
80002ab2:	30 18       	mov	r8,1
80002ab4:	c1 28       	rjmp	80002ad8 <sd_mmc_spi_check_presence+0x84>
  }
  else
  {
    // If memory already initialized, send a CRC command (CMD59) (supported only if card is initialized)
    if ((r1 = sd_mmc_spi_send_command(MMC_CRC_ON_OFF, 0)) == 0x00)
80002ab6:	30 0b       	mov	r11,0
80002ab8:	33 bc       	mov	r12,59
80002aba:	f0 1f 00 0c 	mcall	80002ae8 <sd_mmc_spi_check_presence+0x94>
80002abe:	18 98       	mov	r8,r12
80002ac0:	48 b9       	lddpc	r9,80002aec <sd_mmc_spi_check_presence+0x98>
80002ac2:	b2 88       	st.b	r9[0x0],r8
80002ac4:	48 a8       	lddpc	r8,80002aec <sd_mmc_spi_check_presence+0x98>
80002ac6:	11 88       	ld.ub	r8,r8[0x0]
80002ac8:	58 08       	cp.w	r8,0
80002aca:	c0 31       	brne	80002ad0 <sd_mmc_spi_check_presence+0x7c>
      return true;
80002acc:	30 18       	mov	r8,1
80002ace:	c0 58       	rjmp	80002ad8 <sd_mmc_spi_check_presence+0x84>
    sd_mmc_spi_init_done = false;
80002ad0:	48 49       	lddpc	r9,80002ae0 <sd_mmc_spi_check_presence+0x8c>
80002ad2:	30 08       	mov	r8,0
80002ad4:	b2 88       	st.b	r9[0x0],r8
    return false;
80002ad6:	30 08       	mov	r8,0
  }
}
80002ad8:	10 9c       	mov	r12,r8
80002ada:	2f fd       	sub	sp,-4
80002adc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ae0:	00 00       	add	r0,r0
80002ae2:	00 24       	rsub	r4,r0
80002ae4:	80 00       	ld.sh	r0,r0[0x0]
80002ae6:	3d 32       	mov	r2,-45
80002ae8:	80 00       	ld.sh	r0,r0[0x0]
80002aea:	23 54       	sub	r4,53
80002aec:	00 00       	add	r0,r0
80002aee:	03 3c       	ld.ub	r12,r1++

80002af0 <sd_mmc_spi_mem_check>:
//!
//! @return bit
//!   The memory is ready     -> true
//!   The memory check failed -> false
bool sd_mmc_spi_mem_check(void)
{
80002af0:	eb cd 40 80 	pushm	r7,lr
80002af4:	1a 97       	mov	r7,sp
  if (sd_mmc_spi_check_presence())
80002af6:	f0 1f 00 0b 	mcall	80002b20 <sd_mmc_spi_mem_check+0x30>
80002afa:	18 98       	mov	r8,r12
80002afc:	58 08       	cp.w	r8,0
80002afe:	c0 d0       	breq	80002b18 <sd_mmc_spi_mem_check+0x28>
  {
    if (sd_mmc_spi_init_done == false)
80002b00:	48 98       	lddpc	r8,80002b24 <sd_mmc_spi_mem_check+0x34>
80002b02:	11 88       	ld.ub	r8,r8[0x0]
80002b04:	ec 18 00 01 	eorl	r8,0x1
80002b08:	5c 58       	castu.b	r8
80002b0a:	c0 50       	breq	80002b14 <sd_mmc_spi_mem_check+0x24>
    {
      return sd_mmc_spi_internal_init();
80002b0c:	f0 1f 00 07 	mcall	80002b28 <sd_mmc_spi_mem_check+0x38>
80002b10:	18 98       	mov	r8,r12
80002b12:	c0 48       	rjmp	80002b1a <sd_mmc_spi_mem_check+0x2a>
    }
    else
      return true;
80002b14:	30 18       	mov	r8,1
80002b16:	c0 28       	rjmp	80002b1a <sd_mmc_spi_mem_check+0x2a>
  }
  return false;
80002b18:	30 08       	mov	r8,0
}
80002b1a:	10 9c       	mov	r12,r8
80002b1c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b20:	80 00       	ld.sh	r0,r0[0x0]
80002b22:	2a 54       	sub	r4,-91
80002b24:	00 00       	add	r0,r0
80002b26:	00 24       	rsub	r4,r0
80002b28:	80 00       	ld.sh	r0,r0[0x0]
80002b2a:	20 08       	sub	r8,0

80002b2c <sdramc_ck_delay>:
/*! \brief Waits during at least the specified delay before returning.
 *
 * \param ck Number of HSB clock cycles to wait.
 */
static void sdramc_ck_delay(unsigned long ck)
{
80002b2c:	eb cd 40 80 	pushm	r7,lr
80002b30:	1a 97       	mov	r7,sp
80002b32:	20 3d       	sub	sp,12
80002b34:	ef 4c ff f4 	st.w	r7[-12],r12
  // Use the CPU cycle counter (CPU and HSB clocks are the same).
  unsigned long delay_start_cycle = Get_system_register(AVR32_COUNT);
80002b38:	e1 b8 00 42 	mfsr	r8,0x108
80002b3c:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned long delay_end_cycle = delay_start_cycle + ck;
80002b40:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b44:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002b48:	f2 08 00 08 	add	r8,r9,r8
80002b4c:	ef 48 ff fc 	st.w	r7[-4],r8

  // To be safer, the end of wait is based on an inequality test, so CPU cycle
  // counter wrap around is checked.
  if (delay_start_cycle > delay_end_cycle)
80002b50:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002b54:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b58:	10 39       	cp.w	r9,r8
80002b5a:	e0 88 00 0a 	brls	80002b6e <sdramc_ck_delay+0x42>
  {
    while ((unsigned long)Get_system_register(AVR32_COUNT) > delay_end_cycle);
80002b5e:	e1 b8 00 42 	mfsr	r8,0x108
80002b62:	10 99       	mov	r9,r8
80002b64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b68:	10 39       	cp.w	r9,r8
80002b6a:	fe 9b ff fa 	brhi	80002b5e <sdramc_ck_delay+0x32>
  }
  while ((unsigned long)Get_system_register(AVR32_COUNT) < delay_end_cycle);
80002b6e:	e1 b8 00 42 	mfsr	r8,0x108
80002b72:	10 99       	mov	r9,r8
80002b74:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b78:	10 39       	cp.w	r9,r8
80002b7a:	cf a3       	brcs	80002b6e <sdramc_ck_delay+0x42>
}
80002b7c:	2f dd       	sub	sp,-12
80002b7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b82:	d7 03       	nop

80002b84 <sdramc_enable_muxed_pins>:
/*! \brief Puts the multiplexed MCU pins used for the SDRAM under control of the
 *         SDRAMC.
 */
#if ( UC3A0 || UC3A3)
static void sdramc_enable_muxed_pins(void)
{
80002b84:	eb cd 40 80 	pushm	r7,lr
80002b88:	1a 97       	mov	r7,sp
    // Enable clock-related pins.
    {AVR32_EBI_SDCK_0_PIN,            AVR32_EBI_SDCK_0_FUNCTION           },
    {AVR32_EBI_SDCKE_0_PIN,           AVR32_EBI_SDCKE_0_FUNCTION          }
  };

  gpio_enable_module(SDRAMC_EBI_GPIO_MAP, sizeof(SDRAMC_EBI_GPIO_MAP) / sizeof(SDRAMC_EBI_GPIO_MAP[0]));
80002b8a:	32 7b       	mov	r11,39
80002b8c:	48 3c       	lddpc	r12,80002b98 <sdramc_enable_muxed_pins+0x14>
80002b8e:	f0 1f 00 04 	mcall	80002b9c <sdramc_enable_muxed_pins+0x18>
}
80002b92:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b96:	00 00       	add	r0,r0
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	54 00       	stdsp	sp[0x100],r0
80002b9c:	80 00       	ld.sh	r0,r0[0x0]
80002b9e:	44 4c       	lddsp	r12,sp[0x110]

80002ba0 <sdramc_init>:
{
}
#endif

void sdramc_init(unsigned long hsb_hz)
{
80002ba0:	eb cd 40 80 	pushm	r7,lr
80002ba4:	1a 97       	mov	r7,sp
80002ba6:	20 5d       	sub	sp,20
80002ba8:	ef 4c ff ec 	st.w	r7[-20],r12
  unsigned long hsb_mhz_dn = hsb_hz / 1000000;
80002bac:	ee f9 ff ec 	ld.w	r9,r7[-20]
80002bb0:	e0 68 de 83 	mov	r8,56963
80002bb4:	ea 18 43 1b 	orh	r8,0x431b
80002bb8:	f2 08 06 48 	mulu.d	r8,r9,r8
80002bbc:	f2 08 16 12 	lsr	r8,r9,0x12
80002bc0:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned long hsb_mhz_up = (hsb_hz + 999999) / 1000000;
80002bc4:	ee f8 ff ec 	ld.w	r8,r7[-20]
80002bc8:	ee 7a 42 3f 	mov	r10,999999
80002bcc:	f0 0a 00 09 	add	r9,r8,r10
80002bd0:	e0 68 de 83 	mov	r8,56963
80002bd4:	ea 18 43 1b 	orh	r8,0x431b
80002bd8:	f2 08 06 48 	mulu.d	r8,r9,r8
80002bdc:	f2 08 16 12 	lsr	r8,r9,0x12
80002be0:	ef 48 ff f4 	st.w	r7[-12],r8
  volatile ATPASTE2(U, SDRAM_DBW) *sdram = SDRAM;
80002be4:	fc 18 d0 00 	movh	r8,0xd000
80002be8:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int i;

  // Put the multiplexed MCU pins used for the SDRAM under control of the SDRAMC.
  sdramc_enable_muxed_pins();
80002bec:	f0 1f 00 90 	mcall	80002e2c <sdramc_init+0x28c>

  // Enable SDRAM mode for CS1.
#if (defined AVR32_HMATRIX)
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR] |= 1 << AVR32_EBI_SDRAM_CS;
80002bf0:	fe 68 10 00 	mov	r8,-126976
80002bf4:	fe 69 10 00 	mov	r9,-126976
80002bf8:	f2 f9 01 24 	ld.w	r9,r9[292]
80002bfc:	a1 b9       	sbr	r9,0x1
80002bfe:	f1 49 01 24 	st.w	r8[292],r9
  AVR32_HMATRIX.sfr[AVR32_EBI_HMATRIX_NR];
80002c02:	fe 68 10 00 	mov	r8,-126976
80002c06:	f0 f8 01 24 	ld.w	r8,r8[292]
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80002c0a:	fe 6a 20 00 	mov	r10,-122880
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
      ((( SDRAM_ROW_BITS                 -   11) << AVR32_SDRAMC_CR_NR_OFFSET  ) & AVR32_SDRAMC_CR_NR_MASK  ) |
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
80002c0e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002c12:	12 98       	mov	r8,r9
80002c14:	a3 78       	lsl	r8,0x3
80002c16:	12 18       	sub	r8,r9
80002c18:	a1 78       	lsl	r8,0x1
80002c1a:	f0 c9 fc 19 	sub	r9,r8,-999
80002c1e:	e0 68 4d d3 	mov	r8,19923
80002c22:	ea 18 10 62 	orh	r8,0x1062
80002c26:	f2 08 06 48 	mulu.d	r8,r9,r8
80002c2a:	f2 08 16 06 	lsr	r8,r9,0x6
80002c2e:	a9 68       	lsl	r8,0x8
80002c30:	10 9b       	mov	r11,r8
80002c32:	e2 1b 0f 00 	andl	r11,0xf00,COH
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
80002c36:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002c3a:	12 98       	mov	r8,r9
80002c3c:	a5 68       	lsl	r8,0x4
80002c3e:	12 18       	sub	r8,r9
80002c40:	a3 68       	lsl	r8,0x2
80002c42:	f0 c9 fc 19 	sub	r9,r8,-999
80002c46:	e0 68 4d d3 	mov	r8,19923
80002c4a:	ea 18 10 62 	orh	r8,0x1062
80002c4e:	f2 08 06 48 	mulu.d	r8,r9,r8
80002c52:	f2 08 16 06 	lsr	r8,r9,0x6
80002c56:	ad 68       	lsl	r8,0xc
80002c58:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002c5c:	10 4b       	or	r11,r8
      ((( SDRAM_BANK_BITS                -    1) << AVR32_SDRAMC_CR_NB_OFFSET  ) & AVR32_SDRAMC_CR_NB_MASK  ) |
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
80002c5e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002c62:	12 98       	mov	r8,r9
80002c64:	a5 68       	lsl	r8,0x4
80002c66:	12 18       	sub	r8,r9
80002c68:	f0 c9 fc 19 	sub	r9,r8,-999
80002c6c:	e0 68 4d d3 	mov	r8,19923
80002c70:	ea 18 10 62 	orh	r8,0x1062
80002c74:	f2 08 06 48 	mulu.d	r8,r9,r8
80002c78:	f2 08 16 06 	lsr	r8,r9,0x6
80002c7c:	b1 68       	lsl	r8,0x10
80002c7e:	e6 18 00 0f 	andh	r8,0xf,COH
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002c82:	10 4b       	or	r11,r8
      ((  SDRAM_CAS                              << AVR32_SDRAMC_CR_CAS_OFFSET ) & AVR32_SDRAMC_CR_CAS_MASK ) |
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
80002c84:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002c88:	12 98       	mov	r8,r9
80002c8a:	a5 68       	lsl	r8,0x4
80002c8c:	12 18       	sub	r8,r9
80002c8e:	f0 c9 fc 19 	sub	r9,r8,-999
80002c92:	e0 68 4d d3 	mov	r8,19923
80002c96:	ea 18 10 62 	orh	r8,0x1062
80002c9a:	f2 08 06 48 	mulu.d	r8,r9,r8
80002c9e:	f2 08 16 06 	lsr	r8,r9,0x6
80002ca2:	b5 68       	lsl	r8,0x14
80002ca4:	e6 18 00 f0 	andh	r8,0xf0,COH
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002ca8:	10 4b       	or	r11,r8
      ((( SDRAM_DBW                      >>   4) << AVR32_SDRAMC_CR_DBW_OFFSET ) & AVR32_SDRAMC_CR_DBW_MASK ) |
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
80002caa:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002cae:	12 98       	mov	r8,r9
80002cb0:	a3 78       	lsl	r8,0x3
80002cb2:	12 08       	add	r8,r9
80002cb4:	a3 68       	lsl	r8,0x2
80002cb6:	12 08       	add	r8,r9
80002cb8:	f0 c9 fc 19 	sub	r9,r8,-999
80002cbc:	e0 68 4d d3 	mov	r8,19923
80002cc0:	ea 18 10 62 	orh	r8,0x1062
80002cc4:	f2 08 06 48 	mulu.d	r8,r9,r8
80002cc8:	f2 08 16 06 	lsr	r8,r9,0x6
80002ccc:	b9 68       	lsl	r8,0x18
80002cce:	e6 18 0f 00 	andh	r8,0xf00,COH
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002cd2:	10 4b       	or	r11,r8
      ((((SDRAM_TWR  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TWR_OFFSET ) & AVR32_SDRAMC_CR_TWR_MASK ) |
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
80002cd4:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002cd8:	12 98       	mov	r8,r9
80002cda:	a5 78       	lsl	r8,0x5
80002cdc:	12 08       	add	r8,r9
80002cde:	a1 78       	lsl	r8,0x1
80002ce0:	12 08       	add	r8,r9
80002ce2:	f0 c9 fc 19 	sub	r9,r8,-999
80002ce6:	e0 68 4d d3 	mov	r8,19923
80002cea:	ea 18 10 62 	orh	r8,0x1062
80002cee:	f2 08 06 48 	mulu.d	r8,r9,r8
80002cf2:	f2 08 16 06 	lsr	r8,r9,0x6
80002cf6:	bd 68       	lsl	r8,0x1c
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
      ((( SDRAM_COL_BITS                 -    8) << AVR32_SDRAMC_CR_NC_OFFSET  ) & AVR32_SDRAMC_CR_NC_MASK  ) |
80002cf8:	f7 e8 10 08 	or	r8,r11,r8
80002cfc:	e8 18 00 d9 	orl	r8,0xd9
  AVR32_HMATRIXB.sfr[AVR32_EBI_HMATRIX_NR];
#endif

  // Configure the SDRAM Controller with SDRAM setup and timing information.
  // All timings below are rounded up because they are minimal values.
  AVR32_SDRAMC.cr =
80002d00:	95 28       	st.w	r10[0x8],r8
      ((((SDRAM_TRC  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRC_OFFSET ) & AVR32_SDRAMC_CR_TRC_MASK ) |
      ((((SDRAM_TRP  * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRP_OFFSET ) & AVR32_SDRAMC_CR_TRP_MASK ) |
      ((((SDRAM_TRCD * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRCD_OFFSET) & AVR32_SDRAMC_CR_TRCD_MASK) |
      ((((SDRAM_TRAS * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TRAS_OFFSET) & AVR32_SDRAMC_CR_TRAS_MASK) |
      ((((SDRAM_TXSR * hsb_mhz_up + 999) / 1000) << AVR32_SDRAMC_CR_TXSR_OFFSET) & AVR32_SDRAMC_CR_TXSR_MASK);
  AVR32_SDRAMC.cr;
80002d02:	fe 68 20 00 	mov	r8,-122880
80002d06:	70 28       	ld.w	r8,r8[0x8]

  // Issue a NOP command to the SDRAM in order to start the generation of SDRAMC signals.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NOP;
80002d08:	fe 68 20 00 	mov	r8,-122880
80002d0c:	30 19       	mov	r9,1
80002d0e:	91 09       	st.w	r8[0x0],r9
  AVR32_SDRAMC.mr;
80002d10:	fe 68 20 00 	mov	r8,-122880
80002d14:	70 08       	ld.w	r8,r8[0x0]
  sdram[0];
80002d16:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d1a:	90 08       	ld.sh	r8,r8[0x0]

  // Wait during the SDRAM stable-clock initialization delay.
  sdramc_us_delay(SDRAM_STABLE_CLOCK_INIT_DELAY, hsb_mhz_up);
80002d1c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002d20:	f0 08 10 64 	mul	r8,r8,100
80002d24:	10 9c       	mov	r12,r8
80002d26:	f0 1f 00 43 	mcall	80002e30 <sdramc_init+0x290>

  // Issue a PRECHARGE ALL command to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_BANKS_PRECHARGE;
80002d2a:	fe 68 20 00 	mov	r8,-122880
80002d2e:	30 29       	mov	r9,2
80002d30:	91 09       	st.w	r8[0x0],r9
  AVR32_SDRAMC.mr;
80002d32:	fe 68 20 00 	mov	r8,-122880
80002d36:	70 08       	ld.w	r8,r8[0x0]
  sdram[0];
80002d38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d3c:	90 08       	ld.sh	r8,r8[0x0]
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);
80002d3e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d42:	12 98       	mov	r8,r9
80002d44:	a5 68       	lsl	r8,0x4
80002d46:	12 18       	sub	r8,r9
80002d48:	f0 c9 fc 19 	sub	r9,r8,-999
80002d4c:	e0 68 4d d3 	mov	r8,19923
80002d50:	ea 18 10 62 	orh	r8,0x1062
80002d54:	f2 08 06 48 	mulu.d	r8,r9,r8
80002d58:	f2 08 16 06 	lsr	r8,r9,0x6
80002d5c:	10 9c       	mov	r12,r8
80002d5e:	f0 1f 00 35 	mcall	80002e30 <sdramc_init+0x290>

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
80002d62:	fe 68 20 00 	mov	r8,-122880
80002d66:	30 49       	mov	r9,4
80002d68:	91 09       	st.w	r8[0x0],r9
  AVR32_SDRAMC.mr;
80002d6a:	fe 68 20 00 	mov	r8,-122880
80002d6e:	70 08       	ld.w	r8,r8[0x0]
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
80002d70:	30 08       	mov	r8,0
80002d72:	ef 48 ff fc 	st.w	r7[-4],r8
80002d76:	c1 c8       	rjmp	80002dae <sdramc_init+0x20e>
  {
    sdram[0];
80002d78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d7c:	90 08       	ld.sh	r8,r8[0x0]
    sdramc_ns_delay(SDRAM_TRFC, hsb_mhz_up);
80002d7e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d82:	12 98       	mov	r8,r9
80002d84:	a5 78       	lsl	r8,0x5
80002d86:	12 08       	add	r8,r9
80002d88:	a1 78       	lsl	r8,0x1
80002d8a:	f0 c9 fc 19 	sub	r9,r8,-999
80002d8e:	e0 68 4d d3 	mov	r8,19923
80002d92:	ea 18 10 62 	orh	r8,0x1062
80002d96:	f2 08 06 48 	mulu.d	r8,r9,r8
80002d9a:	f2 08 16 06 	lsr	r8,r9,0x6
80002d9e:	10 9c       	mov	r12,r8
80002da0:	f0 1f 00 24 	mcall	80002e30 <sdramc_init+0x290>
  sdramc_ns_delay(SDRAM_TRP, hsb_mhz_up);

  // Issue initialization AUTO REFRESH commands to the SDRAM.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_AUTO_REFRESH;
  AVR32_SDRAMC.mr;
  for (i = 0; i < SDRAM_INIT_AUTO_REFRESH_COUNT; i++)
80002da4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002da8:	2f f8       	sub	r8,-1
80002daa:	ef 48 ff fc 	st.w	r7[-4],r8
80002dae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002db2:	58 18       	cp.w	r8,1
80002db4:	fe 98 ff e2 	brls	80002d78 <sdramc_init+0x1d8>
  //  - bit 3: burst type: sequential (0b);
  //  - bits 4 to 6: CAS latency: AVR32_SDRAMC.CR.cas;
  //  - bits 7 to 8: operating mode: standard operation (00b);
  //  - bit 9: write burst mode: programmed burst length (0b);
  //  - all other bits: reserved: 0b.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_LOAD_MODE;
80002db8:	fe 68 20 00 	mov	r8,-122880
80002dbc:	30 39       	mov	r9,3
80002dbe:	91 09       	st.w	r8[0x0],r9
  AVR32_SDRAMC.mr;
80002dc0:	fe 68 20 00 	mov	r8,-122880
80002dc4:	70 08       	ld.w	r8,r8[0x0]
  sdram[0];
80002dc6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dca:	90 08       	ld.sh	r8,r8[0x0]
  sdramc_ns_delay(SDRAM_TMRD, hsb_mhz_up);
80002dcc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002dd0:	a1 78       	lsl	r8,0x1
80002dd2:	f0 c9 fc 19 	sub	r9,r8,-999
80002dd6:	e0 68 4d d3 	mov	r8,19923
80002dda:	ea 18 10 62 	orh	r8,0x1062
80002dde:	f2 08 06 48 	mulu.d	r8,r9,r8
80002de2:	f2 08 16 06 	lsr	r8,r9,0x6
80002de6:	10 9c       	mov	r12,r8
80002de8:	f0 1f 00 12 	mcall	80002e30 <sdramc_init+0x290>

  // Switch the SDRAM Controller to normal mode.
  AVR32_SDRAMC.mr = AVR32_SDRAMC_MR_MODE_NORMAL;
80002dec:	fe 68 20 00 	mov	r8,-122880
80002df0:	30 09       	mov	r9,0
80002df2:	91 09       	st.w	r8[0x0],r9
  AVR32_SDRAMC.mr;
80002df4:	fe 68 20 00 	mov	r8,-122880
80002df8:	70 08       	ld.w	r8,r8[0x0]
  sdram[0];
80002dfa:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002dfe:	90 08       	ld.sh	r8,r8[0x0]

  // Write the refresh period into the SDRAMC Refresh Timer Register.
  // tR is rounded down because it is a maximal value.
  AVR32_SDRAMC.tr = (SDRAM_TR * hsb_mhz_dn) / 1000;
80002e00:	fe 6a 20 00 	mov	r10,-122880
80002e04:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002e08:	e0 68 1e 84 	mov	r8,7812
80002e0c:	b1 39       	mul	r9,r8
80002e0e:	e0 68 4d d3 	mov	r8,19923
80002e12:	ea 18 10 62 	orh	r8,0x1062
80002e16:	f2 08 06 48 	mulu.d	r8,r9,r8
80002e1a:	f2 08 16 06 	lsr	r8,r9,0x6
80002e1e:	95 18       	st.w	r10[0x4],r8
  AVR32_SDRAMC.tr;
80002e20:	fe 68 20 00 	mov	r8,-122880
80002e24:	70 18       	ld.w	r8,r8[0x4]
}
80002e26:	2f bd       	sub	sp,-20
80002e28:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e2c:	80 00       	ld.sh	r0,r0[0x0]
80002e2e:	2b 84       	sub	r4,-72
80002e30:	80 00       	ld.sh	r0,r0[0x0]
80002e32:	2b 2c       	sub	r12,-78

80002e34 <pm_set_osc0_mode>:
 *
 * \param pm Base address of the Power Manager (i.e. &AVR32_PM).
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
80002e34:	eb cd 40 80 	pushm	r7,lr
80002e38:	1a 97       	mov	r7,sp
80002e3a:	20 3d       	sub	sp,12
80002e3c:	ef 4c ff f8 	st.w	r7[-8],r12
80002e40:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002e44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e48:	70 a8       	ld.w	r8,r8[0x28]
80002e4a:	30 09       	mov	r9,0
80002e4c:	ef 49 ff fc 	st.w	r7[-4],r9
80002e50:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
80002e54:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002e58:	5c 58       	castu.b	r8
80002e5a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002e5e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002e62:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e66:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80002e6a:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002e6e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002e72:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e76:	91 a9       	st.w	r8[0x28],r9
}
80002e78:	2f dd       	sub	sp,-12
80002e7a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e7e:	d7 03       	nop

80002e80 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
80002e80:	eb cd 40 80 	pushm	r7,lr
80002e84:	1a 97       	mov	r7,sp
80002e86:	20 2d       	sub	sp,8
80002e88:	ef 4c ff fc 	st.w	r7[-4],r12
80002e8c:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
80002e90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e94:	ec 58 bb 9f 	cp.w	r8,899999
80002e98:	e0 88 00 1a 	brls	80002ecc <pm_enable_osc0_crystal+0x4c>
80002e9c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ea0:	e0 69 c6 bf 	mov	r9,50879
80002ea4:	ea 19 00 2d 	orh	r9,0x2d
80002ea8:	12 38       	cp.w	r8,r9
80002eaa:	e0 88 00 0f 	brls	80002ec8 <pm_enable_osc0_crystal+0x48>
80002eae:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002eb2:	e0 69 11 ff 	mov	r9,4607
80002eb6:	ea 19 00 7a 	orh	r9,0x7a
80002eba:	12 38       	cp.w	r8,r9
80002ebc:	e0 8b 00 04 	brhi	80002ec4 <pm_enable_osc0_crystal+0x44>
80002ec0:	30 68       	mov	r8,6
80002ec2:	c0 28       	rjmp	80002ec6 <pm_enable_osc0_crystal+0x46>
80002ec4:	30 78       	mov	r8,7
80002ec6:	c0 28       	rjmp	80002eca <pm_enable_osc0_crystal+0x4a>
80002ec8:	30 58       	mov	r8,5
80002eca:	c0 28       	rjmp	80002ece <pm_enable_osc0_crystal+0x4e>
80002ecc:	30 48       	mov	r8,4
80002ece:	10 9b       	mov	r11,r8
80002ed0:	ee fc ff fc 	ld.w	r12,r7[-4]
80002ed4:	f0 1f 00 03 	mcall	80002ee0 <pm_enable_osc0_crystal+0x60>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002ed8:	2f ed       	sub	sp,-8
80002eda:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ede:	00 00       	add	r0,r0
80002ee0:	80 00       	ld.sh	r0,r0[0x0]
80002ee2:	2e 34       	sub	r4,-29

80002ee4 <pm_enable_clk0>:


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002ee4:	eb cd 40 80 	pushm	r7,lr
80002ee8:	1a 97       	mov	r7,sp
80002eea:	20 2d       	sub	sp,8
80002eec:	ef 4c ff fc 	st.w	r7[-4],r12
80002ef0:	ef 4b ff f8 	st.w	r7[-8],r11
  pm_enable_clk0_no_wait(pm, startup);
80002ef4:	ee fb ff f8 	ld.w	r11,r7[-8]
80002ef8:	ee fc ff fc 	ld.w	r12,r7[-4]
80002efc:	f0 1f 00 05 	mcall	80002f10 <pm_enable_clk0+0x2c>
  pm_wait_for_clk0_ready(pm);
80002f00:	ee fc ff fc 	ld.w	r12,r7[-4]
80002f04:	f0 1f 00 04 	mcall	80002f14 <pm_enable_clk0+0x30>
}
80002f08:	2f ed       	sub	sp,-8
80002f0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f0e:	00 00       	add	r0,r0
80002f10:	80 00       	ld.sh	r0,r0[0x0]
80002f12:	2f 18       	sub	r8,-15
80002f14:	80 00       	ld.sh	r0,r0[0x0]
80002f16:	2f 72       	sub	r2,-9

80002f18 <pm_enable_clk0_no_wait>:
  pm->mcctrl &= ~AVR32_PM_MCCTRL_OSC0EN_MASK;
}


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
80002f18:	eb cd 40 80 	pushm	r7,lr
80002f1c:	1a 97       	mov	r7,sp
80002f1e:	20 3d       	sub	sp,12
80002f20:	ef 4c ff f8 	st.w	r7[-8],r12
80002f24:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002f28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f2c:	70 a8       	ld.w	r8,r8[0x28]
80002f2e:	30 09       	mov	r9,0
80002f30:	ef 49 ff fc 	st.w	r7[-4],r9
80002f34:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002f38:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f3c:	5c 58       	castu.b	r8
80002f3e:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002f42:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002f46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f4a:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
80002f4e:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002f52:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f5a:	91 a9       	st.w	r8[0x28],r9

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002f5c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f60:	70 08       	ld.w	r8,r8[0x0]
80002f62:	10 99       	mov	r9,r8
80002f64:	a3 a9       	sbr	r9,0x2
80002f66:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f6a:	91 09       	st.w	r8[0x0],r9
}
80002f6c:	2f dd       	sub	sp,-12
80002f6e:	e3 cd 80 80 	ldm	sp++,r7,pc

80002f72 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
80002f72:	eb cd 40 80 	pushm	r7,lr
80002f76:	1a 97       	mov	r7,sp
80002f78:	20 1d       	sub	sp,4
80002f7a:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002f7e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f82:	71 58       	ld.w	r8,r8[0x54]
80002f84:	e2 18 00 80 	andl	r8,0x80,COH
80002f88:	cf b0       	breq	80002f7e <pm_wait_for_clk0_ready+0xc>
}
80002f8a:	2f fd       	sub	sp,-4
80002f8c:	e3 cd 80 80 	ldm	sp++,r7,pc

80002f90 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80002f90:	eb cd 40 80 	pushm	r7,lr
80002f94:	1a 97       	mov	r7,sp
80002f96:	20 6d       	sub	sp,24
80002f98:	ee ce ff f8 	sub	lr,r7,-8
80002f9c:	ef 4c ff f8 	st.w	r7[-8],r12
80002fa0:	ef 4b ff f4 	st.w	r7[-12],r11
80002fa4:	ef 4a ff f0 	st.w	r7[-16],r10
80002fa8:	ef 49 ff ec 	st.w	r7[-20],r9
80002fac:	ef 48 ff e8 	st.w	r7[-24],r8
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80002fb0:	30 08       	mov	r8,0
80002fb2:	ef 48 ff fc 	st.w	r7[-4],r8

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
80002fb6:	7c 18       	ld.w	r8,lr[0x4]
80002fb8:	5c 58       	castu.b	r8
80002fba:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002fbe:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002fc2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fc6:	f1 d9 d0 03 	bfins	r8,r9,0x0,0x3
80002fca:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
80002fce:	7c 08       	ld.w	r8,lr[0x0]
80002fd0:	5c 58       	castu.b	r8
80002fd2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002fd6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002fda:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fde:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
80002fe2:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
80002fe6:	7c 18       	ld.w	r8,lr[0x4]
80002fe8:	5c 58       	castu.b	r8
80002fea:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002fee:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80002ff2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ff6:	f1 d9 d1 03 	bfins	r8,r9,0x8,0x3
80002ffa:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
80002ffe:	7c 08       	ld.w	r8,lr[0x0]
80003000:	5c 58       	castu.b	r8
80003002:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003006:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000300a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000300e:	f1 d9 d1 e1 	bfins	r8,r9,0xf,0x1
80003012:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
80003016:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000301a:	5c 58       	castu.b	r8
8000301c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003020:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003024:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003028:	f1 d9 d2 03 	bfins	r8,r9,0x10,0x3
8000302c:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
80003030:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003034:	5c 58       	castu.b	r8
80003036:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000303a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000303e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003042:	f1 d9 d2 e1 	bfins	r8,r9,0x17,0x1
80003046:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
8000304a:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000304e:	5c 58       	castu.b	r8
80003050:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003054:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003058:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000305c:	f1 d9 d3 03 	bfins	r8,r9,0x18,0x3
80003060:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
80003064:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003068:	5c 58       	castu.b	r8
8000306a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000306e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003072:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003076:	f1 d9 d3 e1 	bfins	r8,r9,0x1f,0x1
8000307a:	ef 48 ff fc 	st.w	r7[-4],r8

  pm->cksel = u_avr32_pm_cksel.cksel;
8000307e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003082:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003086:	91 19       	st.w	r8[0x4],r9

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
80003088:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000308c:	71 58       	ld.w	r8,r8[0x54]
8000308e:	e2 18 00 20 	andl	r8,0x20,COH
80003092:	cf b0       	breq	80003088 <pm_cksel+0xf8>
}
80003094:	2f ad       	sub	sp,-24
80003096:	e3 cd 80 80 	ldm	sp++,r7,pc

8000309a <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
8000309a:	eb cd 40 80 	pushm	r7,lr
8000309e:	1a 97       	mov	r7,sp
800030a0:	20 6d       	sub	sp,24
800030a2:	ee ce ff f8 	sub	lr,r7,-8
800030a6:	ef 4c ff f8 	st.w	r7[-8],r12
800030aa:	ef 4b ff f4 	st.w	r7[-12],r11
800030ae:	ef 4a ff f0 	st.w	r7[-16],r10
800030b2:	ef 49 ff ec 	st.w	r7[-20],r9
800030b6:	ef 48 ff e8 	st.w	r7[-24],r8
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
800030ba:	30 08       	mov	r8,0
800030bc:	ef 48 ff fc 	st.w	r7[-4],r8

  u_avr32_pm_pll.PLL.pllosc   = osc;
800030c0:	ee f8 ff e8 	ld.w	r8,r7[-24]
800030c4:	5c 58       	castu.b	r8
800030c6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800030ca:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800030ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030d2:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800030d6:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_pll.PLL.plldiv   = div;
800030da:	ee f8 ff ec 	ld.w	r8,r7[-20]
800030de:	5c 58       	castu.b	r8
800030e0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800030e4:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800030e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800030ec:	f1 d9 d1 04 	bfins	r8,r9,0x8,0x4
800030f0:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_pll.PLL.pllmul   = mul;
800030f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800030f8:	5c 58       	castu.b	r8
800030fa:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800030fe:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003102:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003106:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
8000310a:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000310e:	7c 08       	ld.w	r8,lr[0x0]
80003110:	5c 58       	castu.b	r8
80003112:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
80003116:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000311a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000311e:	f1 d9 d3 06 	bfins	r8,r9,0x18,0x6
80003122:	ef 48 ff fc 	st.w	r7[-4],r8

  pm->pll[pll] = u_avr32_pm_pll.pll;
80003126:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000312a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000312e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003132:	2f 89       	sub	r9,-8
80003134:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
80003138:	2f ad       	sub	sp,-24
8000313a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000313e <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
8000313e:	eb cd 40 80 	pushm	r7,lr
80003142:	1a 97       	mov	r7,sp
80003144:	20 6d       	sub	sp,24
80003146:	ef 4c ff f8 	st.w	r7[-8],r12
8000314a:	ef 4b ff f4 	st.w	r7[-12],r11
8000314e:	ef 4a ff f0 	st.w	r7[-16],r10
80003152:	ef 49 ff ec 	st.w	r7[-20],r9
80003156:	ef 48 ff e8 	st.w	r7[-24],r8
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000315a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000315e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003162:	2f 89       	sub	r9,-8
80003164:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80003168:	30 09       	mov	r9,0
8000316a:	ef 49 ff fc 	st.w	r7[-4],r9
8000316e:	ef 48 ff fc 	st.w	r7[-4],r8
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80003172:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003176:	5c 58       	castu.b	r8
80003178:	a1 78       	lsl	r8,0x1
8000317a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000317e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003182:	5c 58       	castu.b	r8
80003184:	f3 e8 10 08 	or	r8,r9,r8
80003188:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000318c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003190:	5c 58       	castu.b	r8
80003192:	a3 68       	lsl	r8,0x2
80003194:	5c 58       	castu.b	r8
80003196:	f3 e8 10 08 	or	r8,r9,r8
8000319a:	5c 58       	castu.b	r8
8000319c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800031a0:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800031a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031a8:	f1 d9 d0 43 	bfins	r8,r9,0x2,0x3
800031ac:	ef 48 ff fc 	st.w	r7[-4],r8
  pm->pll[pll] = u_avr32_pm_pll.pll;
800031b0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800031b4:	ee fa ff fc 	ld.w	r10,r7[-4]
800031b8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800031bc:	2f 89       	sub	r9,-8
800031be:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
800031c2:	2f ad       	sub	sp,-24
800031c4:	e3 cd 80 80 	ldm	sp++,r7,pc

800031c8 <pm_pll_enable>:
}


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
800031c8:	eb cd 40 80 	pushm	r7,lr
800031cc:	1a 97       	mov	r7,sp
800031ce:	20 2d       	sub	sp,8
800031d0:	ef 4c ff fc 	st.w	r7[-4],r12
800031d4:	ef 4b ff f8 	st.w	r7[-8],r11
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
800031d8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800031dc:	ee fa ff f8 	ld.w	r10,r7[-8]
800031e0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031e4:	2f 8a       	sub	r10,-8
800031e6:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
800031ea:	10 9a       	mov	r10,r8
800031ec:	a1 aa       	sbr	r10,0x0
800031ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800031f2:	2f 89       	sub	r9,-8
800031f4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
800031f8:	2f ed       	sub	sp,-8
800031fa:	e3 cd 80 80 	ldm	sp++,r7,pc

800031fe <pm_wait_for_pll0_locked>:
  pm->pll[pll] &= ~AVR32_PM_PLLEN_MASK;
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
800031fe:	eb cd 40 80 	pushm	r7,lr
80003202:	1a 97       	mov	r7,sp
80003204:	20 1d       	sub	sp,4
80003206:	ef 4c ff fc 	st.w	r7[-4],r12
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
8000320a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000320e:	71 58       	ld.w	r8,r8[0x54]
80003210:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003214:	cf b0       	breq	8000320a <pm_wait_for_pll0_locked+0xc>
}
80003216:	2f fd       	sub	sp,-4
80003218:	e3 cd 80 80 	ldm	sp++,r7,pc

8000321c <pm_switch_to_clock>:
  return u_avr32_pm_mcctrl.MCCTRL.mcsel;
}


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
8000321c:	eb cd 40 80 	pushm	r7,lr
80003220:	1a 97       	mov	r7,sp
80003222:	20 3d       	sub	sp,12
80003224:	ef 4c ff f8 	st.w	r7[-8],r12
80003228:	ef 4b ff f4 	st.w	r7[-12],r11
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
8000322c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003230:	70 08       	ld.w	r8,r8[0x0]
80003232:	30 09       	mov	r9,0
80003234:	ef 49 ff fc 	st.w	r7[-4],r9
80003238:	ef 48 ff fc 	st.w	r7[-4],r8
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
8000323c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003240:	5c 58       	castu.b	r8
80003242:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003246:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000324a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000324e:	f1 d9 d0 02 	bfins	r8,r9,0x0,0x2
80003252:	ef 48 ff fc 	st.w	r7[-4],r8
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80003256:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000325a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000325e:	91 09       	st.w	r8[0x0],r9
}
80003260:	2f dd       	sub	sp,-12
80003262:	e3 cd 80 80 	ldm	sp++,r7,pc
80003266:	d7 03       	nop

80003268 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80003268:	eb cd 40 80 	pushm	r7,lr
8000326c:	1a 97       	mov	r7,sp
8000326e:	20 3d       	sub	sp,12
80003270:	ef 4c ff fc 	st.w	r7[-4],r12
80003274:	ef 4b ff f8 	st.w	r7[-8],r11
80003278:	ef 4a ff f4 	st.w	r7[-12],r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
8000327c:	ee fb ff f8 	ld.w	r11,r7[-8]
80003280:	ee fc ff fc 	ld.w	r12,r7[-4]
80003284:	f0 1f 00 08 	mcall	800032a4 <pm_switch_to_osc0+0x3c>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80003288:	ee fb ff f4 	ld.w	r11,r7[-12]
8000328c:	ee fc ff fc 	ld.w	r12,r7[-4]
80003290:	f0 1f 00 06 	mcall	800032a8 <pm_switch_to_osc0+0x40>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80003294:	30 1b       	mov	r11,1
80003296:	ee fc ff fc 	ld.w	r12,r7[-4]
8000329a:	f0 1f 00 05 	mcall	800032ac <pm_switch_to_osc0+0x44>
}
8000329e:	2f dd       	sub	sp,-12
800032a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	2e 80       	sub	r0,-24
800032a8:	80 00       	ld.sh	r0,r0[0x0]
800032aa:	2e e4       	sub	r4,-18
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	32 1c       	mov	r12,33

800032b0 <pm_configure_clocks>:

#define PM_MAX_MUL                ((1 << AVR32_PM_PLL0_PLLMUL_SIZE) - 1)


int pm_configure_clocks(pm_freq_param_t *param)
{
800032b0:	eb cd 40 80 	pushm	r7,lr
800032b4:	1a 97       	mov	r7,sp
800032b6:	20 bd       	sub	sp,44
800032b8:	ef 4c ff d4 	st.w	r7[-44],r12
  //  12    8   1  108     1     54    27
  //  12    9   1  120     1     60    15
  //  12    9   1  120     1     60    30
  //  12   10   1  132     1     66    16.5
  //
  unsigned long in_cpu_f  = param->cpu_f;
800032bc:	ee f8 ff d4 	ld.w	r8,r7[-44]
800032c0:	70 08       	ld.w	r8,r8[0x0]
800032c2:	ef 48 ff d8 	st.w	r7[-40],r8
  unsigned long in_osc0_f = param->osc0_f;
800032c6:	ee f8 ff d4 	ld.w	r8,r7[-44]
800032ca:	70 28       	ld.w	r8,r8[0x8]
800032cc:	ef 48 ff dc 	st.w	r7[-36],r8
  unsigned long mul, div, div2_en = 0, div2_cpu = 0, div2_pba = 0;
800032d0:	30 08       	mov	r8,0
800032d2:	ef 48 ff e8 	st.w	r7[-24],r8
800032d6:	30 08       	mov	r8,0
800032d8:	ef 48 ff ec 	st.w	r7[-20],r8
800032dc:	30 08       	mov	r8,0
800032de:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned long pll_freq, rest;
  bool b_div2_pba, b_div2_cpu;

  // Switch to external Oscillator 0
  pm_switch_to_osc0(&AVR32_PM, in_osc0_f, param->osc0_startup);
800032e2:	ee f8 ff d4 	ld.w	r8,r7[-44]
800032e6:	70 38       	ld.w	r8,r8[0xc]
800032e8:	10 9a       	mov	r10,r8
800032ea:	ee fb ff dc 	ld.w	r11,r7[-36]
800032ee:	fe 7c 0c 00 	mov	r12,-62464
800032f2:	f0 1f 00 af 	mcall	800035ac <pm_configure_clocks+0x2fc>

  // Start with CPU freq config
  if (in_cpu_f == in_osc0_f)
800032f6:	ee f9 ff d8 	ld.w	r9,r7[-40]
800032fa:	ee f8 ff dc 	ld.w	r8,r7[-36]
800032fe:	10 39       	cp.w	r9,r8
80003300:	c0 d1       	brne	8000331a <pm_configure_clocks+0x6a>
  {
    param->cpu_f = in_osc0_f;
80003302:	ee f8 ff d4 	ld.w	r8,r7[-44]
80003306:	ee f9 ff dc 	ld.w	r9,r7[-36]
8000330a:	91 09       	st.w	r8[0x0],r9
    param->pba_f = in_osc0_f;
8000330c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80003310:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003314:	91 19       	st.w	r8[0x4],r9
    return PM_FREQ_STATUS_OK;
80003316:	30 08       	mov	r8,0
80003318:	c4 69       	rjmp	800035a4 <pm_configure_clocks+0x2f4>
  else if (in_cpu_f < in_osc0_f)
  {
    // TBD
  }

  rest = in_cpu_f % in_osc0_f;
8000331a:	ee f8 ff d8 	ld.w	r8,r7[-40]
8000331e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003322:	f0 09 0d 08 	divu	r8,r8,r9
80003326:	12 98       	mov	r8,r9
80003328:	ef 48 ff f8 	st.w	r7[-8],r8

  for (div = 1; div < 32; div++)
8000332c:	30 18       	mov	r8,1
8000332e:	ef 48 ff e4 	st.w	r7[-28],r8
80003332:	c1 38       	rjmp	80003358 <pm_configure_clocks+0xa8>
  {
    if ((div * rest) % in_osc0_f == 0)
80003334:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003338:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000333c:	f2 08 02 48 	mul	r8,r9,r8
80003340:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003344:	f0 09 0d 08 	divu	r8,r8,r9
80003348:	12 98       	mov	r8,r9
8000334a:	58 08       	cp.w	r8,0
8000334c:	c0 c0       	breq	80003364 <pm_configure_clocks+0xb4>
    // TBD
  }

  rest = in_cpu_f % in_osc0_f;

  for (div = 1; div < 32; div++)
8000334e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003352:	2f f8       	sub	r8,-1
80003354:	ef 48 ff e4 	st.w	r7[-28],r8
80003358:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000335c:	59 f8       	cp.w	r8,31
8000335e:	fe 98 ff eb 	brls	80003334 <pm_configure_clocks+0x84>
80003362:	c0 28       	rjmp	80003366 <pm_configure_clocks+0xb6>
  {
    if ((div * rest) % in_osc0_f == 0)
      break;
80003364:	d7 03       	nop
  }
  if (div == 32)
80003366:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000336a:	e0 48 00 20 	cp.w	r8,32
8000336e:	c0 31       	brne	80003374 <pm_configure_clocks+0xc4>
    return PM_FREQ_STATUS_FAIL;
80003370:	3f f8       	mov	r8,-1
80003372:	c1 99       	rjmp	800035a4 <pm_configure_clocks+0x2f4>

  mul = (in_cpu_f * div) / in_osc0_f;
80003374:	ee f9 ff d8 	ld.w	r9,r7[-40]
80003378:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000337c:	f2 08 02 48 	mul	r8,r9,r8
80003380:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003384:	f0 09 0d 08 	divu	r8,r8,r9
80003388:	ef 48 ff e0 	st.w	r7[-32],r8

  if (mul > PM_MAX_MUL)
8000338c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003390:	58 f8       	cp.w	r8,15
80003392:	e0 88 00 0f 	brls	800033b0 <pm_configure_clocks+0x100>
    return PM_FREQ_STATUS_FAIL;
80003396:	3f f8       	mov	r8,-1
80003398:	c0 69       	rjmp	800035a4 <pm_configure_clocks+0x2f4>

  // export 2power from PLL div to div2_cpu
  while (!(div % 2))
  {
    div /= 2;
8000339a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000339e:	a1 98       	lsr	r8,0x1
800033a0:	ef 48 ff e4 	st.w	r7[-28],r8
    div2_cpu++;
800033a4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800033a8:	2f f8       	sub	r8,-1
800033aa:	ef 48 ff ec 	st.w	r7[-20],r8
800033ae:	c0 28       	rjmp	800033b2 <pm_configure_clocks+0x102>

  if (mul > PM_MAX_MUL)
    return PM_FREQ_STATUS_FAIL;

  // export 2power from PLL div to div2_cpu
  while (!(div % 2))
800033b0:	d7 03       	nop
800033b2:	ee f8 ff e4 	ld.w	r8,r7[-28]
800033b6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800033ba:	cf 00       	breq	8000339a <pm_configure_clocks+0xea>

  // Here we know the mul and div parameter of the PLL config.
  // . Check out if the PLL has a valid in_cpu_f.
  // . Try to have for the PLL frequency (VCO output) the highest possible value
  //   to reduce jitter.
  while (in_osc0_f * 2 * mul / div < AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
800033bc:	c1 18       	rjmp	800033de <pm_configure_clocks+0x12e>
  {
    if (2 * mul > PM_MAX_MUL)
800033be:	ee f8 ff e0 	ld.w	r8,r7[-32]
800033c2:	a1 78       	lsl	r8,0x1
800033c4:	58 f8       	cp.w	r8,15
800033c6:	e0 8b 00 1f 	brhi	80003404 <pm_configure_clocks+0x154>
      break;
    mul *= 2;
800033ca:	ee f8 ff e0 	ld.w	r8,r7[-32]
800033ce:	a1 78       	lsl	r8,0x1
800033d0:	ef 48 ff e0 	st.w	r7[-32],r8
    div2_cpu++;
800033d4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800033d8:	2f f8       	sub	r8,-1
800033da:	ef 48 ff ec 	st.w	r7[-20],r8

  // Here we know the mul and div parameter of the PLL config.
  // . Check out if the PLL has a valid in_cpu_f.
  // . Try to have for the PLL frequency (VCO output) the highest possible value
  //   to reduce jitter.
  while (in_osc0_f * 2 * mul / div < AVR32_PM_PLL_VCO_RANGE0_MAX_FREQ)
800033de:	ee f9 ff dc 	ld.w	r9,r7[-36]
800033e2:	ee f8 ff e0 	ld.w	r8,r7[-32]
800033e6:	f2 08 02 48 	mul	r8,r9,r8
800033ea:	a1 78       	lsl	r8,0x1
800033ec:	ee f9 ff e4 	ld.w	r9,r7[-28]
800033f0:	f0 09 0d 08 	divu	r8,r8,r9
800033f4:	e0 69 1b ff 	mov	r9,7167
800033f8:	ea 19 0e 4e 	orh	r9,0xe4e
800033fc:	12 38       	cp.w	r8,r9
800033fe:	fe 98 ff e0 	brls	800033be <pm_configure_clocks+0x10e>
80003402:	c0 28       	rjmp	80003406 <pm_configure_clocks+0x156>
  {
    if (2 * mul > PM_MAX_MUL)
      break;
80003404:	d7 03       	nop
    mul *= 2;
    div2_cpu++;
  }

  if (div2_cpu != 0)
80003406:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000340a:	58 08       	cp.w	r8,0
8000340c:	c0 90       	breq	8000341e <pm_configure_clocks+0x16e>
  {
    div2_cpu--;
8000340e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003412:	20 18       	sub	r8,1
80003414:	ef 48 ff ec 	st.w	r7[-20],r8
    div2_en = 1;
80003418:	30 18       	mov	r8,1
8000341a:	ef 48 ff e8 	st.w	r7[-24],r8
  }

  pll_freq = in_osc0_f * mul / (div * (1 << div2_en));
8000341e:	ee f9 ff dc 	ld.w	r9,r7[-36]
80003422:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003426:	f2 08 02 48 	mul	r8,r9,r8
8000342a:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000342e:	ee fa ff e4 	ld.w	r10,r7[-28]
80003432:	f4 09 09 49 	lsl	r9,r10,r9
80003436:	f0 09 0d 08 	divu	r8,r8,r9
8000343a:	ef 48 ff f4 	st.w	r7[-12],r8

  // Update real CPU Frequency
  param->cpu_f = pll_freq / (1 << div2_cpu);
8000343e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003442:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003446:	f2 08 0a 49 	lsr	r9,r9,r8
8000344a:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000344e:	91 09       	st.w	r8[0x0],r9
  mul--;
80003450:	ee f8 ff e0 	ld.w	r8,r7[-32]
80003454:	20 18       	sub	r8,1
80003456:	ef 48 ff e0 	st.w	r7[-32],r8

  pm_pll_setup(&AVR32_PM
8000345a:	31 08       	mov	r8,16
8000345c:	1a d8       	st.w	--sp,r8
8000345e:	30 08       	mov	r8,0
80003460:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003464:	ee fa ff e0 	ld.w	r10,r7[-32]
80003468:	30 0b       	mov	r11,0
8000346a:	fe 7c 0c 00 	mov	r12,-62464
8000346e:	f0 1f 00 51 	mcall	800035b0 <pm_configure_clocks+0x300>
80003472:	2f fd       	sub	sp,-4
  , div // div
  , 0   // osc
  , 16  // lockcount
  );

  pm_pll_set_option(&AVR32_PM
80003474:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003478:	e0 69 67 ff 	mov	r9,26623
8000347c:	ea 19 09 89 	orh	r9,0x989
80003480:	12 38       	cp.w	r8,r9
80003482:	5f 8a       	srls	r10
80003484:	30 08       	mov	r8,0
80003486:	ee f9 ff e8 	ld.w	r9,r7[-24]
8000348a:	30 0b       	mov	r11,0
8000348c:	fe 7c 0c 00 	mov	r12,-62464
80003490:	f0 1f 00 49 	mcall	800035b4 <pm_configure_clocks+0x304>
  , (pll_freq < AVR32_PM_PLL_VCO_RANGE0_MIN_FREQ) ? 1 : 0 // pll_freq
  , div2_en // pll_div2
  , 0 // pll_wbwdisable
  );

  rest = pll_freq;
80003494:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003498:	ef 48 ff f8 	st.w	r7[-8],r8
  while (rest > AVR32_PM_PBA_MAX_FREQ ||
8000349c:	c1 68       	rjmp	800034c8 <pm_configure_clocks+0x218>
         rest != param->pba_f)
  {
    div2_pba++;
8000349e:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034a2:	2f f8       	sub	r8,-1
800034a4:	ef 48 ff f0 	st.w	r7[-16],r8
    rest = pll_freq / (1 << div2_pba);
800034a8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034ac:	ee f9 ff f4 	ld.w	r9,r7[-12]
800034b0:	f2 08 0a 48 	lsr	r8,r9,r8
800034b4:	ef 48 ff f8 	st.w	r7[-8],r8
    if (rest < param->pba_f)
800034b8:	ee f8 ff d4 	ld.w	r8,r7[-44]
800034bc:	70 19       	ld.w	r9,r8[0x4]
800034be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034c2:	10 39       	cp.w	r9,r8
800034c4:	e0 8b 00 13 	brhi	800034ea <pm_configure_clocks+0x23a>
  , div2_en // pll_div2
  , 0 // pll_wbwdisable
  );

  rest = pll_freq;
  while (rest > AVR32_PM_PBA_MAX_FREQ ||
800034c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034cc:	e0 69 14 80 	mov	r9,5248
800034d0:	ea 19 03 ef 	orh	r9,0x3ef
800034d4:	12 38       	cp.w	r8,r9
800034d6:	fe 9b ff e4 	brhi	8000349e <pm_configure_clocks+0x1ee>
         rest != param->pba_f)
800034da:	ee f8 ff d4 	ld.w	r8,r7[-44]
800034de:	70 19       	ld.w	r9,r8[0x4]
  , div2_en // pll_div2
  , 0 // pll_wbwdisable
  );

  rest = pll_freq;
  while (rest > AVR32_PM_PBA_MAX_FREQ ||
800034e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800034e4:	10 39       	cp.w	r9,r8
800034e6:	cd c1       	brne	8000349e <pm_configure_clocks+0x1ee>
800034e8:	c0 28       	rjmp	800034ec <pm_configure_clocks+0x23c>
         rest != param->pba_f)
  {
    div2_pba++;
    rest = pll_freq / (1 << div2_pba);
    if (rest < param->pba_f)
      break;
800034ea:	d7 03       	nop
  }

  // Update real PBA Frequency
  param->pba_f = pll_freq / (1 << div2_pba);
800034ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800034f0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800034f4:	f2 08 0a 49 	lsr	r9,r9,r8
800034f8:	ee f8 ff d4 	ld.w	r8,r7[-44]
800034fc:	91 19       	st.w	r8[0x4],r9

  // Enable PLL0
  pm_pll_enable(&AVR32_PM, 0);
800034fe:	30 0b       	mov	r11,0
80003500:	fe 7c 0c 00 	mov	r12,-62464
80003504:	f0 1f 00 2d 	mcall	800035b8 <pm_configure_clocks+0x308>

  // Wait for PLL0 locked
  pm_wait_for_pll0_locked(&AVR32_PM);
80003508:	fe 7c 0c 00 	mov	r12,-62464
8000350c:	f0 1f 00 2c 	mcall	800035bc <pm_configure_clocks+0x30c>

  if (div2_cpu)
80003510:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003514:	58 08       	cp.w	r8,0
80003516:	c0 a0       	breq	8000352a <pm_configure_clocks+0x27a>
  {
    b_div2_cpu = true;
80003518:	30 18       	mov	r8,1
8000351a:	ef 68 ff ff 	st.b	r7[-1],r8
    div2_cpu--;
8000351e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003522:	20 18       	sub	r8,1
80003524:	ef 48 ff ec 	st.w	r7[-20],r8
80003528:	c0 48       	rjmp	80003530 <pm_configure_clocks+0x280>
  }
  else
    b_div2_cpu = false;
8000352a:	30 08       	mov	r8,0
8000352c:	ef 68 ff ff 	st.b	r7[-1],r8

  if (div2_pba)
80003530:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003534:	58 08       	cp.w	r8,0
80003536:	c0 a0       	breq	8000354a <pm_configure_clocks+0x29a>
  {
    b_div2_pba = true;
80003538:	30 18       	mov	r8,1
8000353a:	ef 68 ff fe 	st.b	r7[-2],r8
    div2_pba--;
8000353e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003542:	20 18       	sub	r8,1
80003544:	ef 48 ff f0 	st.w	r7[-16],r8
80003548:	c0 48       	rjmp	80003550 <pm_configure_clocks+0x2a0>
  }
  else
    b_div2_pba = false;
8000354a:	30 08       	mov	r8,0
8000354c:	ef 68 ff fe 	st.b	r7[-2],r8

  pm_cksel(&AVR32_PM
80003550:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003554:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003558:	ef 3b ff fe 	ld.ub	r11,r7[-2]
8000355c:	ee fa ff ec 	ld.w	r10,r7[-20]
80003560:	1a da       	st.w	--sp,r10
80003562:	1a d8       	st.w	--sp,r8
80003564:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003568:	ee fa ff f0 	ld.w	r10,r7[-16]
8000356c:	fe 7c 0c 00 	mov	r12,-62464
80003570:	f0 1f 00 14 	mcall	800035c0 <pm_configure_clocks+0x310>
80003574:	2f ed       	sub	sp,-8
  , b_div2_pba, div2_pba // PBA
  , b_div2_cpu, div2_cpu // PBB
  , b_div2_cpu, div2_cpu // HSB
  );

  if (param->cpu_f > AVR32_FLASHC_FWS_0_MAX_FREQ)
80003576:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000357a:	70 08       	ld.w	r8,r8[0x0]
8000357c:	e0 69 8a 40 	mov	r9,35392
80003580:	ea 19 01 f7 	orh	r9,0x1f7
80003584:	12 38       	cp.w	r8,r9
80003586:	e0 88 00 06 	brls	80003592 <pm_configure_clocks+0x2e2>
  {
    flashc_set_wait_state(1);
8000358a:	30 1c       	mov	r12,1
8000358c:	f0 1f 00 0e 	mcall	800035c4 <pm_configure_clocks+0x314>
80003590:	c0 48       	rjmp	80003598 <pm_configure_clocks+0x2e8>
      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
#endif
  }
  else
  {
    flashc_set_wait_state(0);
80003592:	30 0c       	mov	r12,0
80003594:	f0 1f 00 0c 	mcall	800035c4 <pm_configure_clocks+0x314>
    else
      flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSDIS, -1);
#endif
  }

  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
80003598:	30 2b       	mov	r11,2
8000359a:	fe 7c 0c 00 	mov	r12,-62464
8000359e:	f0 1f 00 0b 	mcall	800035c8 <pm_configure_clocks+0x318>

  return PM_FREQ_STATUS_OK;
800035a2:	30 08       	mov	r8,0
}
800035a4:	10 9c       	mov	r12,r8
800035a6:	2f 5d       	sub	sp,-44
800035a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800035ac:	80 00       	ld.sh	r0,r0[0x0]
800035ae:	32 68       	mov	r8,38
800035b0:	80 00       	ld.sh	r0,r0[0x0]
800035b2:	30 9a       	mov	r10,9
800035b4:	80 00       	ld.sh	r0,r0[0x0]
800035b6:	31 3e       	mov	lr,19
800035b8:	80 00       	ld.sh	r0,r0[0x0]
800035ba:	31 c8       	mov	r8,28
800035bc:	80 00       	ld.sh	r0,r0[0x0]
800035be:	31 fe       	mov	lr,31
800035c0:	80 00       	ld.sh	r0,r0[0x0]
800035c2:	2f 90       	sub	r0,-7
800035c4:	80 00       	ld.sh	r0,r0[0x0]
800035c6:	35 cc       	mov	r12,92
800035c8:	80 00       	ld.sh	r0,r0[0x0]
800035ca:	32 1c       	mov	r12,33

800035cc <flashc_set_wait_state>:
	return (AVR32_FLASHC.fcr & AVR32_FLASHC_FCR_FWS_MASK) >> AVR32_FLASHC_FCR_FWS_OFFSET;
}


void flashc_set_wait_state(unsigned int wait_state)
{
800035cc:	eb cd 40 80 	pushm	r7,lr
800035d0:	1a 97       	mov	r7,sp
800035d2:	20 2d       	sub	sp,8
800035d4:	ef 4c ff f8 	st.w	r7[-8],r12
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800035d8:	fe 68 14 00 	mov	r8,-125952
800035dc:	70 08       	ld.w	r8,r8[0x0]
800035de:	30 09       	mov	r9,0
800035e0:	ef 49 ff fc 	st.w	r7[-4],r9
800035e4:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800035e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800035ec:	5c 58       	castu.b	r8
800035ee:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800035f2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800035f6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800035fa:	f1 d9 d0 c1 	bfins	r8,r9,0x6,0x1
800035fe:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80003602:	fe 68 14 00 	mov	r8,-125952
80003606:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000360a:	91 09       	st.w	r8[0x0],r9
}
8000360c:	2f ed       	sub	sp,-8
8000360e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003612 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80003612:	eb cd 40 80 	pushm	r7,lr
80003616:	1a 97       	mov	r7,sp
80003618:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000361a:	e1 b8 00 00 	mfsr	r8,0x0
8000361e:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80003622:	d3 03       	ssrf	0x10

	return flags;
80003624:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80003628:	10 9c       	mov	r12,r8
8000362a:	2f fd       	sub	sp,-4
8000362c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003630 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003630:	eb cd 40 80 	pushm	r7,lr
80003634:	1a 97       	mov	r7,sp
80003636:	20 1d       	sub	sp,4
80003638:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
8000363c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003640:	e6 18 00 01 	andh	r8,0x1,COH
80003644:	5f 08       	sreq	r8
80003646:	5c 58       	castu.b	r8
}
80003648:	10 9c       	mov	r12,r8
8000364a:	2f fd       	sub	sp,-4
8000364c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003650 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80003650:	eb cd 40 80 	pushm	r7,lr
80003654:	1a 97       	mov	r7,sp
80003656:	20 1d       	sub	sp,4
80003658:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000365c:	ee fc ff fc 	ld.w	r12,r7[-4]
80003660:	f0 1f 00 05 	mcall	80003674 <cpu_irq_restore+0x24>
80003664:	18 98       	mov	r8,r12
80003666:	58 08       	cp.w	r8,0
80003668:	c0 20       	breq	8000366c <cpu_irq_restore+0x1c>
      cpu_irq_enable();
8000366a:	d5 03       	csrf	0x10
   }

	barrier();
}
8000366c:	2f fd       	sub	sp,-4
8000366e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003672:	00 00       	add	r0,r0
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	36 30       	mov	r0,99

80003678 <pdca_get_handler>:

#include "compiler.h"
#include "pdca.h"

volatile avr32_pdca_channel_t *pdca_get_handler(uint8_t pdca_ch_number)
{
80003678:	eb cd 40 80 	pushm	r7,lr
8000367c:	1a 97       	mov	r7,sp
8000367e:	20 2d       	sub	sp,8
80003680:	18 98       	mov	r8,r12
80003682:	ef 68 ff f8 	st.b	r7[-8],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel
		= &AVR32_PDCA.channel[pdca_ch_number];
80003686:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000368a:	a7 68       	lsl	r8,0x6
8000368c:	e0 38 00 00 	sub	r8,65536
80003690:	ef 48 ff fc 	st.w	r7[-4],r8

	if (pdca_ch_number >= AVR32_PDCA_CHANNEL_LENGTH) {
80003694:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80003698:	30 e8       	mov	r8,14
8000369a:	f0 09 18 00 	cp.b	r9,r8
8000369e:	e0 88 00 04 	brls	800036a6 <pdca_get_handler+0x2e>
		return (volatile avr32_pdca_channel_t *)PDCA_INVALID_ARGUMENT;
800036a2:	3f f8       	mov	r8,-1
800036a4:	c0 38       	rjmp	800036aa <pdca_get_handler+0x32>
	}

	return pdca_channel;
800036a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800036aa:	10 9c       	mov	r12,r8
800036ac:	2f ed       	sub	sp,-8
800036ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800036b2:	d7 03       	nop

800036b4 <pdca_init_channel>:

uint32_t pdca_init_channel(uint8_t pdca_ch_number,
		const pdca_channel_options_t *opt)
{
800036b4:	eb cd 40 80 	pushm	r7,lr
800036b8:	1a 97       	mov	r7,sp
800036ba:	20 4d       	sub	sp,16
800036bc:	18 98       	mov	r8,r12
800036be:	ef 4b ff f0 	st.w	r7[-16],r11
800036c2:	ef 68 ff f4 	st.b	r7[-12],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800036c6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800036ca:	10 9c       	mov	r12,r8
800036cc:	f0 1f 00 26 	mcall	80003764 <pdca_init_channel+0xb0>
800036d0:	18 98       	mov	r8,r12
			pdca_ch_number);
800036d2:	ef 48 ff f8 	st.w	r7[-8],r8

	pdca_disable_interrupt_transfer_complete(pdca_ch_number); 
800036d6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800036da:	10 9c       	mov	r12,r8
800036dc:	f0 1f 00 23 	mcall	80003768 <pdca_init_channel+0xb4>
	pdca_disable_interrupt_reload_counter_zero(pdca_ch_number);
800036e0:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800036e4:	10 9c       	mov	r12,r8
800036e6:	f0 1f 00 22 	mcall	8000376c <pdca_init_channel+0xb8>
	
	irqflags_t flags = cpu_irq_save();
800036ea:	f0 1f 00 22 	mcall	80003770 <pdca_init_channel+0xbc>
800036ee:	18 98       	mov	r8,r12
800036f0:	ef 48 ff fc 	st.w	r7[-4],r8

	pdca_channel->mar = (uint32_t)opt->addr;
800036f4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800036f8:	70 08       	ld.w	r8,r8[0x0]
800036fa:	10 99       	mov	r9,r8
800036fc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003700:	91 09       	st.w	r8[0x0],r9
	pdca_channel->tcr = opt->size;
80003702:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003706:	70 19       	ld.w	r9,r8[0x4]
80003708:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000370c:	91 29       	st.w	r8[0x8],r9
	pdca_channel->psr = opt->pid;
8000370e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003712:	70 49       	ld.w	r9,r8[0x10]
80003714:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003718:	91 19       	st.w	r8[0x4],r9
	pdca_channel->marr = (uint32_t)opt->r_addr;
8000371a:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000371e:	70 28       	ld.w	r8,r8[0x8]
80003720:	10 99       	mov	r9,r8
80003722:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003726:	91 39       	st.w	r8[0xc],r9
	pdca_channel->tcrr = opt->r_size;
80003728:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000372c:	70 39       	ld.w	r9,r8[0xc]
8000372e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003732:	91 49       	st.w	r8[0x10],r9
	pdca_channel->mr =
80003734:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003738:	70 59       	ld.w	r9,r8[0x14]
8000373a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000373e:	91 69       	st.w	r8[0x18],r9
#if (AVR32_PDCA_H_VERSION >= 120)
			opt->etrig << AVR32_PDCA_ETRIG_OFFSET |
#endif
			opt->transfer_size << AVR32_PDCA_SIZE_OFFSET;
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
80003740:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003744:	e0 69 01 00 	mov	r9,256
80003748:	91 59       	st.w	r8[0x14],r9
	pdca_channel->isr;
8000374a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000374e:	70 b8       	ld.w	r8,r8[0x2c]
	
	cpu_irq_restore(flags);
80003750:	ee fc ff fc 	ld.w	r12,r7[-4]
80003754:	f0 1f 00 08 	mcall	80003774 <pdca_init_channel+0xc0>

	return PDCA_SUCCESS;
80003758:	30 08       	mov	r8,0
}
8000375a:	10 9c       	mov	r12,r8
8000375c:	2f cd       	sub	sp,-16
8000375e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003762:	00 00       	add	r0,r0
80003764:	80 00       	ld.sh	r0,r0[0x0]
80003766:	36 78       	mov	r8,103
80003768:	80 00       	ld.sh	r0,r0[0x0]
8000376a:	38 48       	mov	r8,-124
8000376c:	80 00       	ld.sh	r0,r0[0x0]
8000376e:	38 98       	mov	r8,-119
80003770:	80 00       	ld.sh	r0,r0[0x0]
80003772:	36 12       	mov	r2,97
80003774:	80 00       	ld.sh	r0,r0[0x0]
80003776:	36 50       	mov	r0,101

80003778 <pdca_disable>:

	return (pdca_channel->sr & AVR32_PDCA_TEN_MASK) != 0;
}

void pdca_disable(uint8_t pdca_ch_number)
{
80003778:	eb cd 40 80 	pushm	r7,lr
8000377c:	1a 97       	mov	r7,sp
8000377e:	20 2d       	sub	sp,8
80003780:	18 98       	mov	r8,r12
80003782:	ef 68 ff f8 	st.b	r7[-8],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003786:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000378a:	10 9c       	mov	r12,r8
8000378c:	f0 1f 00 06 	mcall	800037a4 <pdca_disable+0x2c>
80003790:	18 98       	mov	r8,r12
			pdca_ch_number);
80003792:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Disable transfer */
	pdca_channel->cr = AVR32_PDCA_TDIS_MASK;
80003796:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000379a:	30 29       	mov	r9,2
8000379c:	91 59       	st.w	r8[0x14],r9
}
8000379e:	2f ed       	sub	sp,-8
800037a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800037a4:	80 00       	ld.sh	r0,r0[0x0]
800037a6:	36 78       	mov	r8,103

800037a8 <pdca_enable>:

void pdca_enable(uint8_t pdca_ch_number)
{
800037a8:	eb cd 40 80 	pushm	r7,lr
800037ac:	1a 97       	mov	r7,sp
800037ae:	20 2d       	sub	sp,8
800037b0:	18 98       	mov	r8,r12
800037b2:	ef 68 ff f8 	st.b	r7[-8],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800037b6:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800037ba:	10 9c       	mov	r12,r8
800037bc:	f0 1f 00 06 	mcall	800037d4 <pdca_enable+0x2c>
800037c0:	18 98       	mov	r8,r12
			pdca_ch_number);
800037c2:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable transfer */
	pdca_channel->cr = AVR32_PDCA_TEN_MASK;
800037c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800037ca:	30 19       	mov	r9,1
800037cc:	91 59       	st.w	r8[0x14],r9
}
800037ce:	2f ed       	sub	sp,-8
800037d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800037d4:	80 00       	ld.sh	r0,r0[0x0]
800037d6:	36 78       	mov	r8,103

800037d8 <pdca_load_channel>:
	return pdca_channel->tcr;
}

void pdca_load_channel(uint8_t pdca_ch_number, volatile void *addr,
		uint32_t size)
{
800037d8:	eb cd 40 80 	pushm	r7,lr
800037dc:	1a 97       	mov	r7,sp
800037de:	20 5d       	sub	sp,20
800037e0:	18 98       	mov	r8,r12
800037e2:	ef 4b ff f0 	st.w	r7[-16],r11
800037e6:	ef 4a ff ec 	st.w	r7[-20],r10
800037ea:	ef 68 ff f4 	st.b	r7[-12],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800037ee:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800037f2:	10 9c       	mov	r12,r8
800037f4:	f0 1f 00 12 	mcall	8000383c <pdca_load_channel+0x64>
800037f8:	18 98       	mov	r8,r12
			pdca_ch_number);
800037fa:	ef 48 ff f8 	st.w	r7[-8],r8

	irqflags_t flags = cpu_irq_save();
800037fe:	f0 1f 00 11 	mcall	80003840 <pdca_load_channel+0x68>
80003802:	18 98       	mov	r8,r12
80003804:	ef 48 ff fc 	st.w	r7[-4],r8

	pdca_channel->mar = (uint32_t)addr;
80003808:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000380c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003810:	91 09       	st.w	r8[0x0],r9
	pdca_channel->tcr = size;
80003812:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003816:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000381a:	91 29       	st.w	r8[0x8],r9
	pdca_channel->cr = AVR32_PDCA_ECLR_MASK;
8000381c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003820:	e0 69 01 00 	mov	r9,256
80003824:	91 59       	st.w	r8[0x14],r9
	pdca_channel->isr;
80003826:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000382a:	70 b8       	ld.w	r8,r8[0x2c]

	cpu_irq_restore(flags);
8000382c:	ee fc ff fc 	ld.w	r12,r7[-4]
80003830:	f0 1f 00 05 	mcall	80003844 <pdca_load_channel+0x6c>
}
80003834:	2f bd       	sub	sp,-20
80003836:	e3 cd 80 80 	ldm	sp++,r7,pc
8000383a:	00 00       	add	r0,r0
8000383c:	80 00       	ld.sh	r0,r0[0x0]
8000383e:	36 78       	mov	r8,103
80003840:	80 00       	ld.sh	r0,r0[0x0]
80003842:	36 12       	mov	r2,97
80003844:	80 00       	ld.sh	r0,r0[0x0]
80003846:	36 50       	mov	r0,101

80003848 <pdca_disable_interrupt_transfer_complete>:

	pdca_channel->ier = AVR32_PDCA_TERR_MASK;
}

void pdca_disable_interrupt_transfer_complete(uint8_t pdca_ch_number)
{
80003848:	eb cd 40 80 	pushm	r7,lr
8000384c:	1a 97       	mov	r7,sp
8000384e:	20 3d       	sub	sp,12
80003850:	18 98       	mov	r8,r12
80003852:	ef 68 ff f4 	st.b	r7[-12],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
80003856:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000385a:	10 9c       	mov	r12,r8
8000385c:	f0 1f 00 0c 	mcall	8000388c <pdca_disable_interrupt_transfer_complete+0x44>
80003860:	18 98       	mov	r8,r12
			pdca_ch_number);
80003862:	ef 48 ff f8 	st.w	r7[-8],r8

	irqflags_t flags = cpu_irq_save();
80003866:	f0 1f 00 0b 	mcall	80003890 <pdca_disable_interrupt_transfer_complete+0x48>
8000386a:	18 98       	mov	r8,r12
8000386c:	ef 48 ff fc 	st.w	r7[-4],r8

	pdca_channel->idr = AVR32_PDCA_TRC_MASK;
80003870:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003874:	30 29       	mov	r9,2
80003876:	91 99       	st.w	r8[0x24],r9
	pdca_channel->isr;
80003878:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000387c:	70 b8       	ld.w	r8,r8[0x2c]

	cpu_irq_restore(flags);
8000387e:	ee fc ff fc 	ld.w	r12,r7[-4]
80003882:	f0 1f 00 05 	mcall	80003894 <pdca_disable_interrupt_transfer_complete+0x4c>
}
80003886:	2f dd       	sub	sp,-12
80003888:	e3 cd 80 80 	ldm	sp++,r7,pc
8000388c:	80 00       	ld.sh	r0,r0[0x0]
8000388e:	36 78       	mov	r8,103
80003890:	80 00       	ld.sh	r0,r0[0x0]
80003892:	36 12       	mov	r2,97
80003894:	80 00       	ld.sh	r0,r0[0x0]
80003896:	36 50       	mov	r0,101

80003898 <pdca_disable_interrupt_reload_counter_zero>:

	pdca_channel->ier = AVR32_PDCA_TRC_MASK;
}

void pdca_disable_interrupt_reload_counter_zero(uint8_t pdca_ch_number)
{
80003898:	eb cd 40 80 	pushm	r7,lr
8000389c:	1a 97       	mov	r7,sp
8000389e:	20 3d       	sub	sp,12
800038a0:	18 98       	mov	r8,r12
800038a2:	ef 68 ff f4 	st.b	r7[-12],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800038a6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800038aa:	10 9c       	mov	r12,r8
800038ac:	f0 1f 00 0c 	mcall	800038dc <pdca_disable_interrupt_reload_counter_zero+0x44>
800038b0:	18 98       	mov	r8,r12
			pdca_ch_number);
800038b2:	ef 48 ff f8 	st.w	r7[-8],r8

	irqflags_t flags = cpu_irq_save();
800038b6:	f0 1f 00 0b 	mcall	800038e0 <pdca_disable_interrupt_reload_counter_zero+0x48>
800038ba:	18 98       	mov	r8,r12
800038bc:	ef 48 ff fc 	st.w	r7[-4],r8

	pdca_channel->idr = AVR32_PDCA_RCZ_MASK;
800038c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038c4:	30 19       	mov	r9,1
800038c6:	91 99       	st.w	r8[0x24],r9
	pdca_channel->isr;
800038c8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038cc:	70 b8       	ld.w	r8,r8[0x2c]

	cpu_irq_restore(flags);
800038ce:	ee fc ff fc 	ld.w	r12,r7[-4]
800038d2:	f0 1f 00 05 	mcall	800038e4 <pdca_disable_interrupt_reload_counter_zero+0x4c>
}
800038d6:	2f dd       	sub	sp,-12
800038d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800038dc:	80 00       	ld.sh	r0,r0[0x0]
800038de:	36 78       	mov	r8,103
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	36 12       	mov	r2,97
800038e4:	80 00       	ld.sh	r0,r0[0x0]
800038e6:	36 50       	mov	r0,101

800038e8 <pdca_get_transfer_status>:

	pdca_channel->ier = AVR32_PDCA_RCZ_MASK;
}

uint32_t pdca_get_transfer_status(uint8_t pdca_ch_number)
{
800038e8:	eb cd 40 80 	pushm	r7,lr
800038ec:	1a 97       	mov	r7,sp
800038ee:	20 2d       	sub	sp,8
800038f0:	18 98       	mov	r8,r12
800038f2:	ef 68 ff f8 	st.b	r7[-8],r8
	/* get the correct channel pointer */
	volatile avr32_pdca_channel_t *pdca_channel = pdca_get_handler(
800038f6:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800038fa:	10 9c       	mov	r12,r8
800038fc:	f0 1f 00 06 	mcall	80003914 <pdca_get_transfer_status+0x2c>
80003900:	18 98       	mov	r8,r12
			pdca_ch_number);
80003902:	ef 48 ff fc 	st.w	r7[-4],r8

	return pdca_channel->isr;
80003906:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000390a:	70 b8       	ld.w	r8,r8[0x2c]
}
8000390c:	10 9c       	mov	r12,r8
8000390e:	2f ed       	sub	sp,-8
80003910:	e3 cd 80 80 	ldm	sp++,r7,pc
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	36 78       	mov	r8,103

80003918 <getBaudDiv>:
/** The SPI mutex. */
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
80003918:	eb cd 40 80 	pushm	r7,lr
8000391c:	1a 97       	mov	r7,sp
8000391e:	20 3d       	sub	sp,12
80003920:	ef 4c ff f8 	st.w	r7[-8],r12
80003924:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80003928:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000392c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003930:	f2 08 00 08 	add	r8,r9,r8
80003934:	20 18       	sub	r8,1
80003936:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000393a:	f0 09 0d 08 	divu	r8,r8,r9
8000393e:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv <= 0 || baudDiv > 255) {
80003942:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003946:	58 08       	cp.w	r8,0
80003948:	c0 70       	breq	80003956 <getBaudDiv+0x3e>
8000394a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000394e:	e0 48 00 ff 	cp.w	r8,255
80003952:	e0 88 00 04 	brls	8000395a <getBaudDiv+0x42>
		return -1;
80003956:	3f f8       	mov	r8,-1
80003958:	c0 48       	rjmp	80003960 <getBaudDiv+0x48>
	}

	return baudDiv;
8000395a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000395e:	5c 88       	casts.h	r8
}
80003960:	10 9c       	mov	r12,r8
80003962:	2f dd       	sub	sp,-12
80003964:	e3 cd 80 80 	ldm	sp++,r7,pc

80003968 <spi_initMaster>:
	return SPI_OK;
}

spi_status_t spi_initMaster(volatile avr32_spi_t *spi,
		const spi_options_t *options)
{
80003968:	eb cd 40 80 	pushm	r7,lr
8000396c:	1a 97       	mov	r7,sp
8000396e:	20 3d       	sub	sp,12
80003970:	ef 4c ff f8 	st.w	r7[-8],r12
80003974:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (options->modfdis > 1) {
80003978:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000397c:	f1 39 00 0d 	ld.ub	r9,r8[13]
80003980:	30 18       	mov	r8,1
80003982:	f0 09 18 00 	cp.b	r9,r8
80003986:	e0 88 00 04 	brls	8000398e <spi_initMaster+0x26>
		return SPI_ERROR_ARGUMENT;
8000398a:	30 28       	mov	r8,2
8000398c:	c3 48       	rjmp	800039f4 <spi_initMaster+0x8c>
	}

	/* Reset. */
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
8000398e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003992:	e0 69 00 80 	mov	r9,128
80003996:	91 09       	st.w	r8[0x0],r9

	/* Master Mode. */
	u_avr32_spi_mr.mr = spi->mr;
80003998:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000399c:	70 18       	ld.w	r8,r8[0x4]
8000399e:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.mstr = 1;
800039a2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039a6:	30 19       	mov	r9,1
800039a8:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800039ac:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.modfdis = options->modfdis;
800039b0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800039b4:	f1 38 00 0d 	ld.ub	r8,r8[13]
800039b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800039bc:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800039c0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039c4:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800039c8:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.llb = 0;
800039cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039d0:	30 09       	mov	r9,0
800039d2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
800039d6:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
800039da:	ee f8 ff fc 	ld.w	r8,r7[-4]
800039de:	30 f9       	mov	r9,15
800039e0:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800039e4:	ef 48 ff fc 	st.w	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
800039e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800039ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800039f0:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
800039f2:	30 08       	mov	r8,0
}
800039f4:	10 9c       	mov	r12,r8
800039f6:	2f dd       	sub	sp,-12
800039f8:	e3 cd 80 80 	ldm	sp++,r7,pc

800039fc <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
		uint8_t variable_ps,
		uint8_t pcs_decode,
		uint8_t delay)
{
800039fc:	eb cd 40 80 	pushm	r7,lr
80003a00:	1a 97       	mov	r7,sp
80003a02:	20 5d       	sub	sp,20
80003a04:	ef 4c ff f8 	st.w	r7[-8],r12
80003a08:	12 98       	mov	r8,r9
80003a0a:	16 99       	mov	r9,r11
80003a0c:	ef 69 ff f4 	st.b	r7[-12],r9
80003a10:	14 99       	mov	r9,r10
80003a12:	ef 69 ff f0 	st.b	r7[-16],r9
80003a16:	ef 68 ff ec 	st.b	r7[-20],r8
	u_avr32_spi_mr_t u_avr32_spi_mr;

	if (variable_ps > 1 ||
80003a1a:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003a1e:	30 18       	mov	r8,1
80003a20:	f0 09 18 00 	cp.b	r9,r8
80003a24:	e0 8b 00 09 	brhi	80003a36 <spi_selectionMode+0x3a>
80003a28:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80003a2c:	30 18       	mov	r8,1
80003a2e:	f0 09 18 00 	cp.b	r9,r8
80003a32:	e0 88 00 04 	brls	80003a3a <spi_selectionMode+0x3e>
			pcs_decode > 1) {
		return SPI_ERROR_ARGUMENT;
80003a36:	30 28       	mov	r8,2
80003a38:	c2 88       	rjmp	80003a88 <spi_selectionMode+0x8c>
	}

	u_avr32_spi_mr.mr = spi->mr;
80003a3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a3e:	70 18       	ld.w	r8,r8[0x4]
80003a40:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.ps = variable_ps;
80003a44:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003a48:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003a4c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003a50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a54:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003a58:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003a5c:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80003a60:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003a64:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003a68:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003a6c:	f1 d9 d0 41 	bfins	r8,r9,0x2,0x1
80003a70:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_spi_mr.MR.dlybcs = delay;
80003a74:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80003a78:	ef 68 ff fc 	st.b	r7[-4],r8
	spi->mr = u_avr32_spi_mr.mr;
80003a7c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003a80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a84:	91 19       	st.w	r8[0x4],r9

	return SPI_OK;
80003a86:	30 08       	mov	r8,0
}
80003a88:	10 9c       	mov	r12,r8
80003a8a:	2f bd       	sub	sp,-20
80003a8c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003a90 <spi_selectChip>:

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003a90:	eb cd 40 80 	pushm	r7,lr
80003a94:	1a 97       	mov	r7,sp
80003a96:	20 2d       	sub	sp,8
80003a98:	ef 4c ff fc 	st.w	r7[-4],r12
80003a9c:	16 98       	mov	r8,r11
80003a9e:	ef 68 ff f8 	st.b	r7[-8],r8
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003aa2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aa6:	70 18       	ld.w	r8,r8[0x4]
80003aa8:	10 99       	mov	r9,r8
80003aaa:	ea 19 00 0f 	orh	r9,0xf
80003aae:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ab2:	91 19       	st.w	r8[0x4],r9

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80003ab4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ab8:	70 18       	ld.w	r8,r8[0x4]
80003aba:	e2 18 00 04 	andl	r8,0x4,COH
80003abe:	c1 90       	breq	80003af0 <spi_selectChip+0x60>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80003ac0:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80003ac4:	30 e8       	mov	r8,14
80003ac6:	f0 09 18 00 	cp.b	r9,r8
80003aca:	e0 88 00 04 	brls	80003ad2 <spi_selectChip+0x42>
			return SPI_ERROR_ARGUMENT;
80003ace:	30 28       	mov	r8,2
80003ad0:	c2 88       	rjmp	80003b20 <spi_selectChip+0x90>
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003ad2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ad6:	70 19       	ld.w	r9,r8[0x4]
				(chip << AVR32_SPI_MR_PCS_OFFSET);
80003ad8:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003adc:	b1 68       	lsl	r8,0x10
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
80003ade:	ea 18 ff f0 	orh	r8,0xfff0
80003ae2:	e8 18 ff ff 	orl	r8,0xffff
80003ae6:	10 69       	and	r9,r8
80003ae8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003aec:	91 19       	st.w	r8[0x4],r9
80003aee:	c1 88       	rjmp	80003b1e <spi_selectChip+0x8e>
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
80003af0:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80003af4:	30 38       	mov	r8,3
80003af6:	f0 09 18 00 	cp.b	r9,r8
80003afa:	e0 88 00 04 	brls	80003b02 <spi_selectChip+0x72>
			return SPI_ERROR_ARGUMENT;
80003afe:	30 28       	mov	r8,2
80003b00:	c1 08       	rjmp	80003b20 <spi_selectChip+0x90>
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80003b02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b06:	70 19       	ld.w	r9,r8[0x4]
80003b08:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003b0c:	2f 08       	sub	r8,-16
80003b0e:	30 1a       	mov	r10,1
80003b10:	f4 08 09 48 	lsl	r8,r10,r8
80003b14:	5c d8       	com	r8
80003b16:	10 69       	and	r9,r8
80003b18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b1c:	91 19       	st.w	r8[0x4],r9
	}

	return SPI_OK;
80003b1e:	30 08       	mov	r8,0
}
80003b20:	10 9c       	mov	r12,r8
80003b22:	2f ed       	sub	sp,-8
80003b24:	e3 cd 80 80 	ldm	sp++,r7,pc

80003b28 <spi_unselectChip>:

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
80003b28:	eb cd 40 80 	pushm	r7,lr
80003b2c:	1a 97       	mov	r7,sp
80003b2e:	20 3d       	sub	sp,12
80003b30:	ef 4c ff f8 	st.w	r7[-8],r12
80003b34:	16 98       	mov	r8,r11
80003b36:	ef 68 ff f4 	st.b	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003b3a:	e0 68 3a 98 	mov	r8,15000
80003b3e:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003b42:	c0 f8       	rjmp	80003b60 <spi_unselectChip+0x38>
		if (!timeout--) {
80003b44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b48:	58 08       	cp.w	r8,0
80003b4a:	5f 08       	sreq	r8
80003b4c:	5c 58       	castu.b	r8
80003b4e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003b52:	20 19       	sub	r9,1
80003b54:	ef 49 ff fc 	st.w	r7[-4],r9
80003b58:	58 08       	cp.w	r8,0
80003b5a:	c0 30       	breq	80003b60 <spi_unselectChip+0x38>
			return SPI_ERROR_TIMEOUT;
80003b5c:	30 18       	mov	r8,1
80003b5e:	c1 68       	rjmp	80003b8a <spi_unselectChip+0x62>

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003b60:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b64:	70 48       	ld.w	r8,r8[0x10]
80003b66:	e2 18 02 00 	andl	r8,0x200,COH
80003b6a:	ce d0       	breq	80003b44 <spi_unselectChip+0x1c>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003b6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b70:	70 18       	ld.w	r8,r8[0x4]
80003b72:	10 99       	mov	r9,r8
80003b74:	ea 19 00 0f 	orh	r9,0xf
80003b78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b7c:	91 19       	st.w	r8[0x4],r9

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003b7e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003b82:	fc 19 01 00 	movh	r9,0x100
80003b86:	91 09       	st.w	r8[0x0],r9

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
#endif

	return SPI_OK;
80003b88:	30 08       	mov	r8,0
}
80003b8a:	10 9c       	mov	r12,r8
80003b8c:	2f dd       	sub	sp,-12
80003b8e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b92:	d7 03       	nop

80003b94 <spi_setupChipReg>:

spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
		const spi_options_t *options,
		uint32_t pb_hz)
{
80003b94:	eb cd 40 80 	pushm	r7,lr
80003b98:	1a 97       	mov	r7,sp
80003b9a:	20 5d       	sub	sp,20
80003b9c:	ef 4c ff f4 	st.w	r7[-12],r12
80003ba0:	ef 4b ff f0 	st.w	r7[-16],r11
80003ba4:	ef 4a ff ec 	st.w	r7[-20],r10
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003ba8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bac:	f1 39 00 0c 	ld.ub	r9,r8[12]
80003bb0:	30 38       	mov	r8,3
80003bb2:	f0 09 18 00 	cp.b	r9,r8
80003bb6:	e0 8b 00 1d 	brhi	80003bf0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
80003bba:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bbe:	f1 39 00 0b 	ld.ub	r9,r8[11]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003bc2:	30 18       	mov	r8,1
80003bc4:	f0 09 18 00 	cp.b	r9,r8
80003bc8:	e0 8b 00 14 	brhi	80003bf0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003bcc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bd0:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003bd4:	30 78       	mov	r8,7
80003bd6:	f0 09 18 00 	cp.b	r9,r8
80003bda:	e0 88 00 0b 	brls	80003bf0 <spi_setupChipReg+0x5c>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
80003bde:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003be2:	f1 39 00 08 	ld.ub	r9,r8[8]
		const spi_options_t *options,
		uint32_t pb_hz)
{
	u_avr32_spi_csr_t u_avr32_spi_csr;

	if (options->spi_mode > 3 ||
80003be6:	31 08       	mov	r8,16
80003be8:	f0 09 18 00 	cp.b	r9,r8
80003bec:	e0 88 00 04 	brls	80003bf4 <spi_setupChipReg+0x60>
			options->stay_act > 1 ||
			options->bits < 8 || options->bits > 16) {
		return SPI_ERROR_ARGUMENT;
80003bf0:	30 28       	mov	r8,2
80003bf2:	c8 d8       	rjmp	80003d0c <spi_setupChipReg+0x178>
	}

	int baudDiv = getBaudDiv(options->baudrate, pb_hz);
80003bf4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003bf8:	70 18       	ld.w	r8,r8[0x4]
80003bfa:	ee fb ff ec 	ld.w	r11,r7[-20]
80003bfe:	10 9c       	mov	r12,r8
80003c00:	f0 1f 00 45 	mcall	80003d14 <spi_setupChipReg+0x180>
80003c04:	18 98       	mov	r8,r12
80003c06:	ef 48 ff fc 	st.w	r7[-4],r8

	if (baudDiv < 0) {
80003c0a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c0e:	58 08       	cp.w	r8,0
80003c10:	c0 34       	brge	80003c16 <spi_setupChipReg+0x82>
		return SPI_ERROR_ARGUMENT;
80003c12:	30 28       	mov	r8,2
80003c14:	c7 c8       	rjmp	80003d0c <spi_setupChipReg+0x178>
	}

	/* Will use CSR0 offsets; these are the same for CSR0 to CSR3. */
	u_avr32_spi_csr.csr = 0;
80003c16:	30 08       	mov	r8,0
80003c18:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.cpol   = options->spi_mode >> 1;
80003c1c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c20:	f1 38 00 0c 	ld.ub	r8,r8[12]
80003c24:	a1 98       	lsr	r8,0x1
80003c26:	5c 58       	castu.b	r8
80003c28:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c2c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003c30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c34:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
80003c38:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.ncpha  = (options->spi_mode & 0x1) ^ 0x1;
80003c3c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c40:	f1 38 00 0c 	ld.ub	r8,r8[12]
80003c44:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c48:	5f 08       	sreq	r8
80003c4a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003c4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c52:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80003c56:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.csaat  = options->stay_act;
80003c5a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c5e:	f1 38 00 0b 	ld.ub	r8,r8[11]
80003c62:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003c66:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003c6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c6e:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80003c72:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.bits   = options->bits - 8;
80003c76:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003c7a:	f1 38 00 08 	ld.ub	r8,r8[8]
80003c7e:	20 88       	sub	r8,8
80003c80:	5c 58       	castu.b	r8
80003c82:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003c86:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80003c8a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003c8e:	f1 d9 d0 84 	bfins	r8,r9,0x4,0x4
80003c92:	ef 48 ff f8 	st.w	r7[-8],r8
	u_avr32_spi_csr.CSR.scbr   = baudDiv;
80003c96:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c9a:	5c 58       	castu.b	r8
80003c9c:	ef 68 ff fa 	st.b	r7[-6],r8
	u_avr32_spi_csr.CSR.dlybs  = options->spck_delay;
80003ca0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ca4:	f1 38 00 09 	ld.ub	r8,r8[9]
80003ca8:	ef 68 ff f9 	st.b	r7[-7],r8
	u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003cac:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003cb0:	f1 38 00 0a 	ld.ub	r8,r8[10]
80003cb4:	ef 68 ff f8 	st.b	r7[-8],r8

	switch (options->reg) {
80003cb8:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003cbc:	11 88       	ld.ub	r8,r8[0x0]
80003cbe:	58 18       	cp.w	r8,1
80003cc0:	c1 10       	breq	80003ce2 <spi_setupChipReg+0x14e>
80003cc2:	e0 89 00 05 	brgt	80003ccc <spi_setupChipReg+0x138>
80003cc6:	58 08       	cp.w	r8,0
80003cc8:	c0 70       	breq	80003cd6 <spi_setupChipReg+0x142>
80003cca:	c1 e8       	rjmp	80003d06 <spi_setupChipReg+0x172>
80003ccc:	58 28       	cp.w	r8,2
80003cce:	c1 00       	breq	80003cee <spi_setupChipReg+0x15a>
80003cd0:	58 38       	cp.w	r8,3
80003cd2:	c1 40       	breq	80003cfa <spi_setupChipReg+0x166>
80003cd4:	c1 98       	rjmp	80003d06 <spi_setupChipReg+0x172>
	case 0:
		spi->csr0 = u_avr32_spi_csr.csr;
80003cd6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003cda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cde:	91 c9       	st.w	r8[0x30],r9
		break;
80003ce0:	c1 58       	rjmp	80003d0a <spi_setupChipReg+0x176>

	case 1:
		spi->csr1 = u_avr32_spi_csr.csr;
80003ce2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003ce6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cea:	91 d9       	st.w	r8[0x34],r9
		break;
80003cec:	c0 f8       	rjmp	80003d0a <spi_setupChipReg+0x176>

	case 2:
		spi->csr2 = u_avr32_spi_csr.csr;
80003cee:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003cf2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003cf6:	91 e9       	st.w	r8[0x38],r9
		break;
80003cf8:	c0 98       	rjmp	80003d0a <spi_setupChipReg+0x176>

	case 3:
		spi->csr3 = u_avr32_spi_csr.csr;
80003cfa:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003cfe:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003d02:	91 f9       	st.w	r8[0x3c],r9
		break;
80003d04:	c0 38       	rjmp	80003d0a <spi_setupChipReg+0x176>

	default:
		return SPI_ERROR_ARGUMENT;
80003d06:	30 28       	mov	r8,2
80003d08:	c0 28       	rjmp	80003d0c <spi_setupChipReg+0x178>
			}
		}
	}
#endif

	return SPI_OK;
80003d0a:	30 08       	mov	r8,0
}
80003d0c:	10 9c       	mov	r12,r8
80003d0e:	2f bd       	sub	sp,-20
80003d10:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d14:	80 00       	ld.sh	r0,r0[0x0]
80003d16:	39 18       	mov	r8,-111

80003d18 <spi_enable>:

void spi_enable(volatile avr32_spi_t *spi)
{
80003d18:	eb cd 40 80 	pushm	r7,lr
80003d1c:	1a 97       	mov	r7,sp
80003d1e:	20 1d       	sub	sp,4
80003d20:	ef 4c ff fc 	st.w	r7[-4],r12
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80003d24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d28:	30 19       	mov	r9,1
80003d2a:	91 09       	st.w	r8[0x0],r9
}
80003d2c:	2f fd       	sub	sp,-4
80003d2e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003d32 <spi_write>:
{
	return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
80003d32:	eb cd 40 80 	pushm	r7,lr
80003d36:	1a 97       	mov	r7,sp
80003d38:	20 3d       	sub	sp,12
80003d3a:	ef 4c ff f8 	st.w	r7[-8],r12
80003d3e:	16 98       	mov	r8,r11
80003d40:	ef 58 ff f4 	st.h	r7[-12],r8
	uint32_t timeout = SPI_TIMEOUT;
80003d44:	e0 68 3a 98 	mov	r8,15000
80003d48:	ef 48 ff fc 	st.w	r7[-4],r8

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003d4c:	c0 f8       	rjmp	80003d6a <spi_write+0x38>
		if (!timeout--) {
80003d4e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003d52:	58 08       	cp.w	r8,0
80003d54:	5f 08       	sreq	r8
80003d56:	5c 58       	castu.b	r8
80003d58:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003d5c:	20 19       	sub	r9,1
80003d5e:	ef 49 ff fc 	st.w	r7[-4],r9
80003d62:	58 08       	cp.w	r8,0
80003d64:	c0 30       	breq	80003d6a <spi_write+0x38>
			return SPI_ERROR_TIMEOUT;
80003d66:	30 18       	mov	r8,1
80003d68:	c0 d8       	rjmp	80003d82 <spi_write+0x50>

spi_status_t spi_write(volatile avr32_spi_t *spi, uint16_t data)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003d6a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d6e:	70 48       	ld.w	r8,r8[0x10]
80003d70:	e2 18 00 02 	andl	r8,0x2,COH
80003d74:	ce d0       	breq	80003d4e <spi_write+0x1c>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80003d76:	ef 19 ff f4 	ld.uh	r9,r7[-12]
80003d7a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d7e:	91 39       	st.w	r8[0xc],r9

	return SPI_OK;
80003d80:	30 08       	mov	r8,0
}
80003d82:	10 9c       	mov	r12,r8
80003d84:	2f dd       	sub	sp,-12
80003d86:	e3 cd 80 80 	ldm	sp++,r7,pc

80003d8a <spi_read>:
{
	return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
80003d8a:	eb cd 40 80 	pushm	r7,lr
80003d8e:	1a 97       	mov	r7,sp
80003d90:	20 3d       	sub	sp,12
80003d92:	ef 4c ff f8 	st.w	r7[-8],r12
80003d96:	ef 4b ff f4 	st.w	r7[-12],r11
	unsigned int timeout = SPI_TIMEOUT;
80003d9a:	e0 68 3a 98 	mov	r8,15000
80003d9e:	ef 48 ff fc 	st.w	r7[-4],r8

	while ((spi->sr &
80003da2:	c0 f8       	rjmp	80003dc0 <spi_read+0x36>
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
			(AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
		if (!timeout--) {
80003da4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003da8:	58 08       	cp.w	r8,0
80003daa:	5f 08       	sreq	r8
80003dac:	5c 58       	castu.b	r8
80003dae:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003db2:	20 19       	sub	r9,1
80003db4:	ef 49 ff fc 	st.w	r7[-4],r9
80003db8:	58 08       	cp.w	r8,0
80003dba:	c0 30       	breq	80003dc0 <spi_read+0x36>
			return SPI_ERROR_TIMEOUT;
80003dbc:	30 18       	mov	r8,1
80003dbe:	c1 18       	rjmp	80003de0 <spi_read+0x56>

spi_status_t spi_read(volatile avr32_spi_t *spi, uint16_t *data)
{
	unsigned int timeout = SPI_TIMEOUT;

	while ((spi->sr &
80003dc0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dc4:	70 48       	ld.w	r8,r8[0x10]
80003dc6:	e2 18 02 01 	andl	r8,0x201,COH
80003dca:	e0 48 02 01 	cp.w	r8,513
80003dce:	ce b1       	brne	80003da4 <spi_read+0x1a>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	*data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003dd0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003dd4:	70 28       	ld.w	r8,r8[0x8]
80003dd6:	5c 88       	casts.h	r8
80003dd8:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003ddc:	b2 08       	st.h	r9[0x0],r8

	return SPI_OK;
80003dde:	30 08       	mov	r8,0
}
80003de0:	10 9c       	mov	r12,r8
80003de2:	2f dd       	sub	sp,-12
80003de4:	e3 cd 80 80 	ldm	sp++,r7,pc

80003de8 <cpu_irq_is_enabled_flags>:

	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003de8:	eb cd 40 80 	pushm	r7,lr
80003dec:	1a 97       	mov	r7,sp
80003dee:	20 1d       	sub	sp,4
80003df0:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80003df4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003df8:	e6 18 00 01 	andh	r8,0x1,COH
80003dfc:	5f 08       	sreq	r8
80003dfe:	5c 58       	castu.b	r8
}
80003e00:	10 9c       	mov	r12,r8
80003e02:	2f fd       	sub	sp,-4
80003e04:	e3 cd 80 80 	ldm	sp++,r7,pc

80003e08 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80003e08:	eb cd 40 80 	pushm	r7,lr
80003e0c:	1a 97       	mov	r7,sp
80003e0e:	20 7d       	sub	sp,28
80003e10:	ef 4c ff ec 	st.w	r7[-20],r12
80003e14:	ef 4b ff e8 	st.w	r7[-24],r11
80003e18:	ef 4a ff e4 	st.w	r7[-28],r10
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80003e1c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003e20:	f0 09 15 04 	lsl	r9,r8,0x4
80003e24:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003e28:	10 39       	cp.w	r9,r8
80003e2a:	e0 8b 00 04 	brhi	80003e32 <usart_set_async_baudrate+0x2a>
80003e2e:	31 08       	mov	r8,16
80003e30:	c0 28       	rjmp	80003e34 <usart_set_async_baudrate+0x2c>
80003e32:	30 88       	mov	r8,8
80003e34:	ef 48 ff f0 	st.w	r7[-16],r8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80003e38:	ee f8 ff e4 	ld.w	r8,r7[-28]
80003e3c:	f0 09 15 03 	lsl	r9,r8,0x3
80003e40:	ee fa ff f0 	ld.w	r10,r7[-16]
80003e44:	ee f8 ff e8 	ld.w	r8,r7[-24]
80003e48:	f4 08 02 48 	mul	r8,r10,r8
80003e4c:	a1 98       	lsr	r8,0x1
80003e4e:	f2 08 00 08 	add	r8,r9,r8
80003e52:	ee fa ff f0 	ld.w	r10,r7[-16]
80003e56:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003e5a:	f4 09 02 49 	mul	r9,r10,r9
80003e5e:	f0 09 0d 08 	divu	r8,r8,r9
80003e62:	ef 48 ff f4 	st.w	r7[-12],r8
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80003e66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e6a:	a3 98       	lsr	r8,0x3
80003e6c:	ef 48 ff f8 	st.w	r7[-8],r8
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);
80003e70:	ee f8 ff f4 	ld.w	r8,r7[-12]
80003e74:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003e78:	ef 48 ff fc 	st.w	r7[-4],r8

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80003e7c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e80:	58 08       	cp.w	r8,0
80003e82:	c0 70       	breq	80003e90 <usart_set_async_baudrate+0x88>
80003e84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003e88:	e0 48 ff ff 	cp.w	r8,65535
80003e8c:	e0 88 00 04 	brls	80003e94 <usart_set_async_baudrate+0x8c>
    return USART_INVALID_INPUT;
80003e90:	30 18       	mov	r8,1
80003e92:	c2 08       	rjmp	80003ed2 <usart_set_async_baudrate+0xca>

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80003e94:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003e98:	70 18       	ld.w	r8,r8[0x4]
80003e9a:	10 99       	mov	r9,r8
80003e9c:	e4 19 ff f7 	andh	r9,0xfff7
80003ea0:	e0 19 fe cf 	andl	r9,0xfecf
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80003ea4:	ee f8 ff f0 	ld.w	r8,r7[-16]
80003ea8:	59 08       	cp.w	r8,16
80003eaa:	c0 40       	breq	80003eb2 <usart_set_async_baudrate+0xaa>
80003eac:	e8 68 00 00 	mov	r8,524288
80003eb0:	c0 28       	rjmp	80003eb4 <usart_set_async_baudrate+0xac>
80003eb2:	30 08       	mov	r8,0
80003eb4:	10 49       	or	r9,r8
80003eb6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003eba:	91 19       	st.w	r8[0x4],r9
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
                fp << AVR32_USART_BRGR_FP_OFFSET;
80003ebc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ec0:	f0 09 15 10 	lsl	r9,r8,0x10
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80003ec4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003ec8:	10 49       	or	r9,r8
80003eca:	ee f8 ff ec 	ld.w	r8,r7[-20]
80003ece:	91 89       	st.w	r8[0x20],r9
                fp << AVR32_USART_BRGR_FP_OFFSET;

  return USART_SUCCESS;
80003ed0:	30 08       	mov	r8,0
}
80003ed2:	10 9c       	mov	r12,r8
80003ed4:	2f 9d       	sub	sp,-28
80003ed6:	e3 cd 80 80 	ldm	sp++,r7,pc
80003eda:	d7 03       	nop

80003edc <usart_reset>:
 */
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
80003edc:	eb cd 40 80 	pushm	r7,lr
80003ee0:	1a 97       	mov	r7,sp
80003ee2:	20 2d       	sub	sp,8
80003ee4:	ef 4c ff f8 	st.w	r7[-8],r12
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80003ee8:	e1 b8 00 00 	mfsr	r8,0x0
80003eec:	10 9c       	mov	r12,r8
80003eee:	f0 1f 00 18 	mcall	80003f4c <usart_reset+0x70>
80003ef2:	18 98       	mov	r8,r12
80003ef4:	ef 68 ff ff 	st.b	r7[-1],r8

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80003ef8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003efc:	30 08       	mov	r8,0
80003efe:	f0 09 18 00 	cp.b	r9,r8
80003f02:	c0 20       	breq	80003f06 <usart_reset+0x2a>
80003f04:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80003f06:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f0a:	3f f9       	mov	r9,-1
80003f0c:	91 39       	st.w	r8[0xc],r9
  usart->csr;
80003f0e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f12:	70 58       	ld.w	r8,r8[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80003f14:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003f18:	30 08       	mov	r8,0
80003f1a:	f0 09 18 00 	cp.b	r9,r8
80003f1e:	c0 20       	breq	80003f22 <usart_reset+0x46>
80003f20:	d5 03       	csrf	0x10

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80003f22:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f26:	30 09       	mov	r9,0
80003f28:	91 19       	st.w	r8[0x4],r9
  usart->rtor = 0;
80003f2a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f2e:	30 09       	mov	r9,0
80003f30:	91 99       	st.w	r8[0x24],r9
  usart->ttgr = 0;
80003f32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f36:	30 09       	mov	r9,0
80003f38:	91 a9       	st.w	r8[0x28],r9

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80003f3a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f3e:	ea 69 61 0c 	mov	r9,680204
80003f42:	91 09       	st.w	r8[0x0],r9
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80003f44:	2f ed       	sub	sp,-8
80003f46:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f4a:	00 00       	add	r0,r0
80003f4c:	80 00       	ld.sh	r0,r0[0x0]
80003f4e:	3d e8       	mov	r8,-34

80003f50 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80003f50:	eb cd 40 80 	pushm	r7,lr
80003f54:	1a 97       	mov	r7,sp
80003f56:	20 3d       	sub	sp,12
80003f58:	ef 4c ff fc 	st.w	r7[-4],r12
80003f5c:	ef 4b ff f8 	st.w	r7[-8],r11
80003f60:	ef 4a ff f4 	st.w	r7[-12],r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80003f64:	ee fc ff fc 	ld.w	r12,r7[-4]
80003f68:	f0 1f 00 54 	mcall	800040b8 <usart_init_rs232+0x168>

  // Check input values.
  if (!opt || // Null pointer.
80003f6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f70:	58 08       	cp.w	r8,0
80003f72:	c3 90       	breq	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80003f74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f78:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003f7a:	30 48       	mov	r8,4
80003f7c:	f0 09 18 00 	cp.b	r9,r8
80003f80:	e0 88 00 32 	brls	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
80003f84:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f88:	11 c9       	ld.ub	r9,r8[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003f8a:	30 98       	mov	r8,9
80003f8c:	f0 09 18 00 	cp.b	r9,r8
80003f90:	e0 8b 00 2a 	brhi	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80003f94:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003f98:	11 d9       	ld.ub	r9,r8[0x5]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003f9a:	30 78       	mov	r8,7
80003f9c:	f0 09 18 00 	cp.b	r9,r8
80003fa0:	e0 8b 00 22 	brhi	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
80003fa4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fa8:	90 39       	ld.sh	r9,r8[0x6]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003faa:	e0 68 01 01 	mov	r8,257
80003fae:	f0 09 19 00 	cp.h	r9,r8
80003fb2:	e0 8b 00 19 	brhi	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
80003fb6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fba:	f1 39 00 08 	ld.ub	r9,r8[8]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003fbe:	30 38       	mov	r8,3
80003fc0:	f0 09 18 00 	cp.b	r9,r8
80003fc4:	e0 8b 00 10 	brhi	80003fe4 <usart_init_rs232+0x94>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80003fc8:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003fcc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fd0:	70 08       	ld.w	r8,r8[0x0]
80003fd2:	12 9a       	mov	r10,r9
80003fd4:	10 9b       	mov	r11,r8
80003fd6:	ee fc ff fc 	ld.w	r12,r7[-4]
80003fda:	f0 1f 00 39 	mcall	800040bc <usart_init_rs232+0x16c>
80003fde:	18 98       	mov	r8,r12
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80003fe0:	58 18       	cp.w	r8,1
80003fe2:	c0 31       	brne	80003fe8 <usart_init_rs232+0x98>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;
80003fe4:	30 18       	mov	r8,1
80003fe6:	c6 48       	rjmp	800040ae <usart_init_rs232+0x15e>

  if (opt->charlength == 9)
80003fe8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003fec:	11 c9       	ld.ub	r9,r8[0x4]
80003fee:	30 98       	mov	r8,9
80003ff0:	f0 09 18 00 	cp.b	r9,r8
80003ff4:	c0 a1       	brne	80004008 <usart_init_rs232+0xb8>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80003ff6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003ffa:	70 18       	ld.w	r8,r8[0x4]
80003ffc:	10 99       	mov	r9,r8
80003ffe:	b1 b9       	sbr	r9,0x11
80004000:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004004:	91 19       	st.w	r8[0x4],r9
80004006:	c0 d8       	rjmp	80004020 <usart_init_rs232+0xd0>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004008:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000400c:	70 19       	ld.w	r9,r8[0x4]
8000400e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004012:	11 c8       	ld.ub	r8,r8[0x4]
80004014:	20 58       	sub	r8,5
80004016:	a7 68       	lsl	r8,0x6
80004018:	10 49       	or	r9,r8
8000401a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000401e:	91 19       	st.w	r8[0x4],r9
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004020:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004024:	70 19       	ld.w	r9,r8[0x4]
80004026:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000402a:	11 d8       	ld.ub	r8,r8[0x5]
8000402c:	f0 0a 15 09 	lsl	r10,r8,0x9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;
80004030:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004034:	f1 38 00 08 	ld.ub	r8,r8[8]
80004038:	af 68       	lsl	r8,0xe
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
8000403a:	f5 e8 10 08 	or	r8,r10,r8
8000403e:	10 49       	or	r9,r8
80004040:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004044:	91 19       	st.w	r8[0x4],r9
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004046:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000404a:	90 39       	ld.sh	r9,r8[0x6]
8000404c:	30 28       	mov	r8,2
8000404e:	f0 09 19 00 	cp.h	r9,r8
80004052:	e0 88 00 14 	brls	8000407a <usart_init_rs232+0x12a>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004056:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000405a:	70 18       	ld.w	r8,r8[0x4]
8000405c:	10 99       	mov	r9,r8
8000405e:	ad b9       	sbr	r9,0xd
80004060:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004064:	91 19       	st.w	r8[0x4],r9
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004066:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000406a:	90 38       	ld.sh	r8,r8[0x6]
8000406c:	5c 78       	castu.h	r8
8000406e:	20 28       	sub	r8,2
80004070:	10 99       	mov	r9,r8
80004072:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004076:	91 a9       	st.w	r8[0x28],r9
80004078:	c0 d8       	rjmp	80004092 <usart_init_rs232+0x142>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000407a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000407e:	70 19       	ld.w	r9,r8[0x4]
80004080:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004084:	90 38       	ld.sh	r8,r8[0x6]
80004086:	5c 78       	castu.h	r8
80004088:	ad 68       	lsl	r8,0xc
8000408a:	10 49       	or	r9,r8
8000408c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004090:	91 19       	st.w	r8[0x4],r9

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004092:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004096:	70 18       	ld.w	r8,r8[0x4]
80004098:	10 99       	mov	r9,r8
8000409a:	e0 19 ff f0 	andl	r9,0xfff0
8000409e:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040a2:	91 19       	st.w	r8[0x4],r9
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
800040a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040a8:	35 09       	mov	r9,80
800040aa:	91 09       	st.w	r8[0x0],r9
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
800040ac:	30 08       	mov	r8,0
}
800040ae:	10 9c       	mov	r12,r8
800040b0:	2f dd       	sub	sp,-12
800040b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800040b6:	00 00       	add	r0,r0
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	3e dc       	mov	r12,-19
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	3e 08       	mov	r8,-32

800040c0 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
800040c0:	eb cd 40 80 	pushm	r7,lr
800040c4:	1a 97       	mov	r7,sp
800040c6:	20 3d       	sub	sp,12
800040c8:	ef 4c ff f8 	st.w	r7[-8],r12
800040cc:	ef 4b ff f4 	st.w	r7[-12],r11
800040d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040d4:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
800040d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800040dc:	70 58       	ld.w	r8,r8[0x14]
800040de:	e2 18 00 02 	andl	r8,0x2,COH
800040e2:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
800040e4:	58 08       	cp.w	r8,0
800040e6:	c0 a0       	breq	800040fa <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800040e8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800040ec:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
800040f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800040f4:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
800040f6:	30 08       	mov	r8,0
800040f8:	c0 28       	rjmp	800040fc <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
800040fa:	30 28       	mov	r8,2
}
800040fc:	10 9c       	mov	r12,r8
800040fe:	2f dd       	sub	sp,-12
80004100:	e3 cd 80 80 	ldm	sp++,r7,pc

80004104 <usart_putchar>:


int usart_putchar(volatile avr32_usart_t *usart, int c)
{
80004104:	eb cd 40 80 	pushm	r7,lr
80004108:	1a 97       	mov	r7,sp
8000410a:	20 3d       	sub	sp,12
8000410c:	ef 4c ff f8 	st.w	r7[-8],r12
80004110:	ef 4b ff f4 	st.w	r7[-12],r11
  int timeout = USART_DEFAULT_TIMEOUT;
80004114:	e0 68 27 10 	mov	r8,10000
80004118:	ef 48 ff fc 	st.w	r7[-4],r8

  do
  {
    if (!timeout--) return USART_FAILURE;
8000411c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004120:	58 08       	cp.w	r8,0
80004122:	5f 08       	sreq	r8
80004124:	5c 58       	castu.b	r8
80004126:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000412a:	20 19       	sub	r9,1
8000412c:	ef 49 ff fc 	st.w	r7[-4],r9
80004130:	58 08       	cp.w	r8,0
80004132:	c0 30       	breq	80004138 <usart_putchar+0x34>
80004134:	3f f8       	mov	r8,-1
80004136:	c0 b8       	rjmp	8000414c <usart_putchar+0x48>
  } while (usart_write_char(usart, c) != USART_SUCCESS);
80004138:	ee fb ff f4 	ld.w	r11,r7[-12]
8000413c:	ee fc ff f8 	ld.w	r12,r7[-8]
80004140:	f0 1f 00 05 	mcall	80004154 <usart_putchar+0x50>
80004144:	18 98       	mov	r8,r12
80004146:	58 08       	cp.w	r8,0
80004148:	ce a1       	brne	8000411c <usart_putchar+0x18>

  return USART_SUCCESS;
8000414a:	30 08       	mov	r8,0
}
8000414c:	10 9c       	mov	r12,r8
8000414e:	2f dd       	sub	sp,-12
80004150:	e3 cd 80 80 	ldm	sp++,r7,pc
80004154:	80 00       	ld.sh	r0,r0[0x0]
80004156:	40 c0       	lddsp	r0,sp[0x30]

80004158 <usart_write_line>:
  return c;
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
80004158:	eb cd 40 80 	pushm	r7,lr
8000415c:	1a 97       	mov	r7,sp
8000415e:	20 2d       	sub	sp,8
80004160:	ef 4c ff fc 	st.w	r7[-4],r12
80004164:	ef 4b ff f8 	st.w	r7[-8],r11
  while (*string != '\0')
80004168:	c0 e8       	rjmp	80004184 <usart_write_line+0x2c>
    usart_putchar(usart, *string++);
8000416a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000416e:	11 88       	ld.ub	r8,r8[0x0]
80004170:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004174:	2f f9       	sub	r9,-1
80004176:	ef 49 ff f8 	st.w	r7[-8],r9
8000417a:	10 9b       	mov	r11,r8
8000417c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004180:	f0 1f 00 05 	mcall	80004194 <usart_write_line+0x3c>
}


void usart_write_line(volatile avr32_usart_t *usart, const char *string)
{
  while (*string != '\0')
80004184:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004188:	11 88       	ld.ub	r8,r8[0x0]
8000418a:	58 08       	cp.w	r8,0
8000418c:	ce f1       	brne	8000416a <usart_write_line+0x12>
    usart_putchar(usart, *string++);
}
8000418e:	2f ed       	sub	sp,-8
80004190:	e3 cd 80 80 	ldm	sp++,r7,pc
80004194:	80 00       	ld.sh	r0,r0[0x0]
80004196:	41 04       	lddsp	r4,sp[0x40]

80004198 <init_dbg_rs232>:
//! ASCII representation of hexadecimal digits.
static const char HEX_DIGITS[16] = "0123456789ABCDEF";


void init_dbg_rs232(long pba_hz)
{
80004198:	eb cd 40 80 	pushm	r7,lr
8000419c:	1a 97       	mov	r7,sp
8000419e:	20 1d       	sub	sp,4
800041a0:	ef 4c ff fc 	st.w	r7[-4],r12
  init_dbg_rs232_ex(DBG_USART_BAUDRATE, pba_hz);
800041a4:	ee fb ff fc 	ld.w	r11,r7[-4]
800041a8:	e0 6c e1 00 	mov	r12,57600
800041ac:	f0 1f 00 03 	mcall	800041b8 <init_dbg_rs232+0x20>
}
800041b0:	2f fd       	sub	sp,-4
800041b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800041b6:	00 00       	add	r0,r0
800041b8:	80 00       	ld.sh	r0,r0[0x0]
800041ba:	41 bc       	lddsp	r12,sp[0x6c]

800041bc <init_dbg_rs232_ex>:


void init_dbg_rs232_ex(unsigned long baudrate, long pba_hz)
{
800041bc:	eb cd 40 80 	pushm	r7,lr
800041c0:	1a 97       	mov	r7,sp
800041c2:	20 5d       	sub	sp,20
800041c4:	ef 4c ff f0 	st.w	r7[-16],r12
800041c8:	ef 4b ff ec 	st.w	r7[-20],r11
    .baudrate = baudrate,
    .charlength = 8,
    .paritytype = USART_NO_PARITY,
    .stopbits = USART_1_STOPBIT,
    .channelmode = USART_NORMAL_CHMODE
  };
800041cc:	ee f8 ff f0 	ld.w	r8,r7[-16]
800041d0:	ef 48 ff f4 	st.w	r7[-12],r8
800041d4:	30 88       	mov	r8,8
800041d6:	ef 68 ff f8 	st.b	r7[-8],r8
800041da:	30 48       	mov	r8,4
800041dc:	ef 68 ff f9 	st.b	r7[-7],r8
800041e0:	30 08       	mov	r8,0
800041e2:	ef 58 ff fa 	st.h	r7[-6],r8
800041e6:	30 08       	mov	r8,0
800041e8:	ef 68 ff fc 	st.b	r7[-4],r8

  // Setup GPIO for debug USART.
  gpio_enable_module(DBG_USART_GPIO_MAP,
800041ec:	30 2b       	mov	r11,2
800041ee:	48 8c       	lddpc	r12,8000420c <init_dbg_rs232_ex+0x50>
800041f0:	f0 1f 00 08 	mcall	80004210 <init_dbg_rs232_ex+0x54>
                     sizeof(DBG_USART_GPIO_MAP) / sizeof(DBG_USART_GPIO_MAP[0]));

  // Initialize it in RS232 mode.
  usart_init_rs232(DBG_USART, &dbg_usart_options, pba_hz);
800041f4:	ee c8 00 0c 	sub	r8,r7,12
800041f8:	ee fa ff ec 	ld.w	r10,r7[-20]
800041fc:	10 9b       	mov	r11,r8
800041fe:	fe 7c 18 00 	mov	r12,-59392
80004202:	f0 1f 00 05 	mcall	80004214 <init_dbg_rs232_ex+0x58>
}
80004206:	2f bd       	sub	sp,-20
80004208:	e3 cd 80 80 	ldm	sp++,r7,pc
8000420c:	80 00       	ld.sh	r0,r0[0x0]
8000420e:	55 38       	stdsp	sp[0x14c],r8
80004210:	80 00       	ld.sh	r0,r0[0x0]
80004212:	44 4c       	lddsp	r12,sp[0x110]
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	3f 50       	mov	r0,-11

80004218 <print_dbg>:


void print_dbg(const char *str)
{
80004218:	eb cd 40 80 	pushm	r7,lr
8000421c:	1a 97       	mov	r7,sp
8000421e:	20 1d       	sub	sp,4
80004220:	ef 4c ff fc 	st.w	r7[-4],r12
  // Redirection to the debug USART.
  print(DBG_USART, str);
80004224:	ee fb ff fc 	ld.w	r11,r7[-4]
80004228:	fe 7c 18 00 	mov	r12,-59392
8000422c:	f0 1f 00 03 	mcall	80004238 <print_dbg+0x20>
}
80004230:	2f fd       	sub	sp,-4
80004232:	e3 cd 80 80 	ldm	sp++,r7,pc
80004236:	00 00       	add	r0,r0
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	42 84       	lddsp	r4,sp[0xa0]

8000423c <print_dbg_char>:


void print_dbg_char(int c)
{
8000423c:	eb cd 40 80 	pushm	r7,lr
80004240:	1a 97       	mov	r7,sp
80004242:	20 1d       	sub	sp,4
80004244:	ef 4c ff fc 	st.w	r7[-4],r12
  // Redirection to the debug USART.
  print_char(DBG_USART, c);
80004248:	ee fb ff fc 	ld.w	r11,r7[-4]
8000424c:	fe 7c 18 00 	mov	r12,-59392
80004250:	f0 1f 00 03 	mcall	8000425c <print_dbg_char+0x20>
}
80004254:	2f fd       	sub	sp,-4
80004256:	e3 cd 80 80 	ldm	sp++,r7,pc
8000425a:	00 00       	add	r0,r0
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	42 ac       	lddsp	r12,sp[0xa8]

80004260 <print_dbg_ulong>:


void print_dbg_ulong(unsigned long n)
{
80004260:	eb cd 40 80 	pushm	r7,lr
80004264:	1a 97       	mov	r7,sp
80004266:	20 1d       	sub	sp,4
80004268:	ef 4c ff fc 	st.w	r7[-4],r12
  // Redirection to the debug USART.
  print_ulong(DBG_USART, n);
8000426c:	ee fb ff fc 	ld.w	r11,r7[-4]
80004270:	fe 7c 18 00 	mov	r12,-59392
80004274:	f0 1f 00 03 	mcall	80004280 <print_dbg_ulong+0x20>
}
80004278:	2f fd       	sub	sp,-4
8000427a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000427e:	00 00       	add	r0,r0
80004280:	80 00       	ld.sh	r0,r0[0x0]
80004282:	42 d4       	lddsp	r4,sp[0xb4]

80004284 <print>:
  print_hex(DBG_USART, n);
}


void print(volatile avr32_usart_t *usart, const char *str)
{
80004284:	eb cd 40 80 	pushm	r7,lr
80004288:	1a 97       	mov	r7,sp
8000428a:	20 2d       	sub	sp,8
8000428c:	ef 4c ff fc 	st.w	r7[-4],r12
80004290:	ef 4b ff f8 	st.w	r7[-8],r11
  // Invoke the USART driver to transmit the input string with the given USART.
  usart_write_line(usart, str);
80004294:	ee fb ff f8 	ld.w	r11,r7[-8]
80004298:	ee fc ff fc 	ld.w	r12,r7[-4]
8000429c:	f0 1f 00 03 	mcall	800042a8 <print+0x24>
}
800042a0:	2f ed       	sub	sp,-8
800042a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800042a6:	00 00       	add	r0,r0
800042a8:	80 00       	ld.sh	r0,r0[0x0]
800042aa:	41 58       	lddsp	r8,sp[0x54]

800042ac <print_char>:


void print_char(volatile avr32_usart_t *usart, int c)
{
800042ac:	eb cd 40 80 	pushm	r7,lr
800042b0:	1a 97       	mov	r7,sp
800042b2:	20 2d       	sub	sp,8
800042b4:	ef 4c ff fc 	st.w	r7[-4],r12
800042b8:	ef 4b ff f8 	st.w	r7[-8],r11
  // Invoke the USART driver to transmit the input character with the given USART.
  usart_putchar(usart, c);
800042bc:	ee fb ff f8 	ld.w	r11,r7[-8]
800042c0:	ee fc ff fc 	ld.w	r12,r7[-4]
800042c4:	f0 1f 00 03 	mcall	800042d0 <print_char+0x24>
}
800042c8:	2f ed       	sub	sp,-8
800042ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800042ce:	00 00       	add	r0,r0
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	41 04       	lddsp	r4,sp[0x40]

800042d4 <print_ulong>:


void print_ulong(volatile avr32_usart_t *usart, unsigned long n)
{
800042d4:	eb cd 40 80 	pushm	r7,lr
800042d8:	1a 97       	mov	r7,sp
800042da:	20 6d       	sub	sp,24
800042dc:	ef 4c ff ec 	st.w	r7[-20],r12
800042e0:	ef 4b ff e8 	st.w	r7[-24],r11
  char tmp[11];
  int i = sizeof(tmp) - 1;
800042e4:	30 a8       	mov	r8,10
800042e6:	ef 48 ff fc 	st.w	r7[-4],r8

  // Convert the given number to an ASCII decimal representation.
  tmp[i] = '\0';
800042ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042ee:	ee 08 00 09 	add	r9,r7,r8
800042f2:	30 08       	mov	r8,0
800042f4:	f3 68 ff f0 	st.b	r9[-16],r8
  do
  {
    tmp[--i] = '0' + n % 10;
800042f8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042fc:	20 18       	sub	r8,1
800042fe:	ef 48 ff fc 	st.w	r7[-4],r8
80004302:	ee fb ff fc 	ld.w	r11,r7[-4]
80004306:	ee fa ff e8 	ld.w	r10,r7[-24]
8000430a:	e0 68 cc cd 	mov	r8,52429
8000430e:	ea 18 cc cc 	orh	r8,0xcccc
80004312:	f4 08 06 48 	mulu.d	r8,r10,r8
80004316:	a3 99       	lsr	r9,0x3
80004318:	12 98       	mov	r8,r9
8000431a:	a3 68       	lsl	r8,0x2
8000431c:	12 08       	add	r8,r9
8000431e:	a1 78       	lsl	r8,0x1
80004320:	f4 08 01 09 	sub	r9,r10,r8
80004324:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
80004328:	2d 08       	sub	r8,-48
8000432a:	5c 58       	castu.b	r8
8000432c:	ee 0b 00 09 	add	r9,r7,r11
80004330:	f3 68 ff f0 	st.b	r9[-16],r8
    n /= 10;
80004334:	ee f9 ff e8 	ld.w	r9,r7[-24]
80004338:	e0 68 cc cd 	mov	r8,52429
8000433c:	ea 18 cc cc 	orh	r8,0xcccc
80004340:	f2 08 06 48 	mulu.d	r8,r9,r8
80004344:	f2 08 16 03 	lsr	r8,r9,0x3
80004348:	ef 48 ff e8 	st.w	r7[-24],r8
  } while (n);
8000434c:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004350:	58 08       	cp.w	r8,0
80004352:	cd 31       	brne	800042f8 <print_ulong+0x24>

  // Transmit the resulting string with the given USART.
  print(usart, tmp + i);
80004354:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004358:	ee c8 00 10 	sub	r8,r7,16
8000435c:	12 08       	add	r8,r9
8000435e:	10 9b       	mov	r11,r8
80004360:	ee fc ff ec 	ld.w	r12,r7[-20]
80004364:	f0 1f 00 03 	mcall	80004370 <print_ulong+0x9c>
}
80004368:	2f ad       	sub	sp,-24
8000436a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000436e:	00 00       	add	r0,r0
80004370:	80 00       	ld.sh	r0,r0[0x0]
80004372:	42 84       	lddsp	r4,sp[0xa0]

80004374 <board_init>:
#if defined (CONF_BOARD_AT45DBX)
#  define AT45DBX_MEM_CNT  1
#endif

void board_init(void)
{
80004374:	eb cd 40 80 	pushm	r7,lr
80004378:	1a 97       	mov	r7,sp
	gpio_configure_pin(LED0_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000437a:	30 3b       	mov	r11,3
8000437c:	33 bc       	mov	r12,59
8000437e:	f0 1f 00 2d 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED1_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004382:	30 3b       	mov	r11,3
80004384:	33 cc       	mov	r12,60
80004386:	f0 1f 00 2b 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED2_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000438a:	30 3b       	mov	r11,3
8000438c:	33 dc       	mov	r12,61
8000438e:	f0 1f 00 29 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED3_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80004392:	30 3b       	mov	r11,3
80004394:	33 ec       	mov	r12,62
80004396:	f0 1f 00 27 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED4_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000439a:	30 3b       	mov	r11,3
8000439c:	33 3c       	mov	r12,51
8000439e:	f0 1f 00 25 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED5_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800043a2:	30 3b       	mov	r11,3
800043a4:	33 4c       	mov	r12,52
800043a6:	f0 1f 00 23 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED6_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800043aa:	30 3b       	mov	r11,3
800043ac:	33 5c       	mov	r12,53
800043ae:	f0 1f 00 21 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(LED7_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
800043b2:	30 3b       	mov	r11,3
800043b4:	33 6c       	mov	r12,54
800043b6:	f0 1f 00 1f 	mcall	80004430 <board_init+0xbc>

	gpio_configure_pin(GPIO_PUSH_BUTTON_0,GPIO_DIR_INPUT);
800043ba:	30 0b       	mov	r11,0
800043bc:	35 8c       	mov	r12,88
800043be:	f0 1f 00 1d 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_PUSH_BUTTON_1,GPIO_DIR_INPUT);
800043c2:	30 0b       	mov	r11,0
800043c4:	35 5c       	mov	r12,85
800043c6:	f0 1f 00 1b 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_PUSH_BUTTON_2,GPIO_DIR_INPUT);
800043ca:	30 0b       	mov	r11,0
800043cc:	35 2c       	mov	r12,82
800043ce:	f0 1f 00 19 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_JOYSTICK_PUSH,GPIO_DIR_INPUT);
800043d2:	30 0b       	mov	r11,0
800043d4:	31 4c       	mov	r12,20
800043d6:	f0 1f 00 17 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_JOYSTICK_LEFT,GPIO_DIR_INPUT);
800043da:	30 0b       	mov	r11,0
800043dc:	31 9c       	mov	r12,25
800043de:	f0 1f 00 15 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_JOYSTICK_UP,GPIO_DIR_INPUT);
800043e2:	30 0b       	mov	r11,0
800043e4:	31 ac       	mov	r12,26
800043e6:	f0 1f 00 13 	mcall	80004430 <board_init+0xbc>
	gpio_configure_pin(GPIO_JOYSTICK_DOWN,GPIO_DIR_INPUT);
800043ea:	30 0b       	mov	r11,0
800043ec:	31 bc       	mov	r12,27
800043ee:	f0 1f 00 11 	mcall	80004430 <board_init+0xbc>
		MREPEAT(AT45DBX_MEM_CNT, AT45DBX_ENABLE_NPCS_PIN, ~)
#  undef AT45DBX_ENABLE_NPCS_PIN
	};

	// Assign I/Os to SPI.
	gpio_enable_module(AT45DBX_SPI_GPIO_MAP,
800043f2:	30 4b       	mov	r11,4
800043f4:	49 0c       	lddpc	r12,80004434 <board_init+0xc0>
800043f6:	f0 1f 00 11 	mcall	80004438 <board_init+0xc4>
		{SD_MMC_SPI_MOSI_PIN, SD_MMC_SPI_MOSI_FUNCTION},
		{SD_MMC_SPI_NPCS_PIN, SD_MMC_SPI_NPCS_FUNCTION},
	};

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
800043fa:	30 4b       	mov	r11,4
800043fc:	49 0c       	lddpc	r12,8000443c <board_init+0xc8>
800043fe:	f0 1f 00 0f 	mcall	80004438 <board_init+0xc4>

	// Configure SD/MMC card detect and write protect pins
#  define SD_MMC_CONFIGURE_CD_WP_PIN(slot, unused) \
	gpio_configure_pin(SD_MMC_##slot##_CD_GPIO,GPIO_DIR_INPUT); \
	gpio_configure_pin(SD_MMC_##slot##_WP_GPIO,GPIO_DIR_INPUT);
	MREPEAT(SD_MMC_SPI_MEM_CNT, SD_MMC_CONFIGURE_CD_WP_PIN, ~)
80004402:	30 0b       	mov	r11,0
80004404:	30 2c       	mov	r12,2
80004406:	f0 1f 00 0b 	mcall	80004430 <board_init+0xbc>
8000440a:	30 0b       	mov	r11,0
8000440c:	30 7c       	mov	r12,7
8000440e:	f0 1f 00 09 	mcall	80004430 <board_init+0xbc>
		{AVR32_TWI_SDA_0_0_PIN, AVR32_TWI_SDA_0_0_FUNCTION},
		{AVR32_TWI_SCL_0_0_PIN, AVR32_TWI_SCL_0_0_FUNCTION},
	};

	// TWI gpio pins configuration
	gpio_enable_module(TWI_GPIO_MAP,
80004412:	30 2b       	mov	r11,2
80004414:	48 bc       	lddpc	r12,80004440 <board_init+0xcc>
80004416:	f0 1f 00 09 	mcall	80004438 <board_init+0xc4>
	// USART GPIO pin configuration.
	static const gpio_map_t COMPORT_GPIO_MAP = {
		{USART_RXD_PIN, USART_RXD_FUNCTION },
		{USART_TXD_PIN, USART_TXD_FUNCTION },
	};
	gpio_enable_module(COMPORT_GPIO_MAP,
8000441a:	30 2b       	mov	r11,2
8000441c:	48 ac       	lddpc	r12,80004444 <board_init+0xd0>
8000441e:	f0 1f 00 07 	mcall	80004438 <board_init+0xc4>
	// USART GPIO pin configuration.
	static const gpio_map_t COMPORT0_GPIO_MAP = {
		{USART0_RXD_PIN, USART0_RXD_FUNCTION },
		{USART0_TXD_PIN, USART0_TXD_FUNCTION },
	};
	gpio_enable_module(COMPORT0_GPIO_MAP,
80004422:	30 2b       	mov	r11,2
80004424:	48 9c       	lddpc	r12,80004448 <board_init+0xd4>
80004426:	f0 1f 00 05 	mcall	80004438 <board_init+0xc4>
			sizeof(COMPORT0_GPIO_MAP) / sizeof(COMPORT0_GPIO_MAP[0]));
#endif
}
8000442a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000442e:	00 00       	add	r0,r0
80004430:	80 00       	ld.sh	r0,r0[0x0]
80004432:	45 cc       	lddsp	r12,sp[0x170]
80004434:	80 00       	ld.sh	r0,r0[0x0]
80004436:	55 48       	stdsp	sp[0x150],r8
80004438:	80 00       	ld.sh	r0,r0[0x0]
8000443a:	44 4c       	lddsp	r12,sp[0x110]
8000443c:	80 00       	ld.sh	r0,r0[0x0]
8000443e:	55 68       	stdsp	sp[0x158],r8
80004440:	80 00       	ld.sh	r0,r0[0x0]
80004442:	55 88       	stdsp	sp[0x160],r8
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	55 98       	stdsp	sp[0x164],r8
80004448:	80 00       	ld.sh	r0,r0[0x0]
8000444a:	55 a8       	stdsp	sp[0x168],r8

8000444c <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
8000444c:	eb cd 40 80 	pushm	r7,lr
80004450:	1a 97       	mov	r7,sp
80004452:	20 4d       	sub	sp,16
80004454:	ef 4c ff f4 	st.w	r7[-12],r12
80004458:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
8000445c:	30 08       	mov	r8,0
8000445e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80004462:	30 08       	mov	r8,0
80004464:	ef 48 ff fc 	st.w	r7[-4],r8
80004468:	c1 c8       	rjmp	800044a0 <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000446a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000446e:	70 19       	ld.w	r9,r8[0x4]
80004470:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004474:	70 08       	ld.w	r8,r8[0x0]
80004476:	12 9b       	mov	r11,r9
80004478:	10 9c       	mov	r12,r8
8000447a:	f0 1f 00 10 	mcall	800044b8 <gpio_enable_module+0x6c>
8000447e:	18 98       	mov	r8,r12
80004480:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004484:	f3 e8 10 08 	or	r8,r9,r8
80004488:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
8000448c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004490:	2f 88       	sub	r8,-8
80004492:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80004496:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000449a:	2f f8       	sub	r8,-1
8000449c:	ef 48 ff fc 	st.w	r7[-4],r8
800044a0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800044a4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800044a8:	10 39       	cp.w	r9,r8
800044aa:	ce 03       	brcs	8000446a <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
800044ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800044b0:	10 9c       	mov	r12,r8
800044b2:	2f cd       	sub	sp,-16
800044b4:	e3 cd 80 80 	ldm	sp++,r7,pc
800044b8:	80 00       	ld.sh	r0,r0[0x0]
800044ba:	44 bc       	lddsp	r12,sp[0x12c]

800044bc <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
800044bc:	eb cd 40 80 	pushm	r7,lr
800044c0:	1a 97       	mov	r7,sp
800044c2:	20 3d       	sub	sp,12
800044c4:	ef 4c ff f8 	st.w	r7[-8],r12
800044c8:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800044cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044d0:	a5 98       	lsr	r8,0x5
800044d2:	a9 68       	lsl	r8,0x8
800044d4:	e0 28 f0 00 	sub	r8,61440
800044d8:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
800044dc:	ee f8 ff f4 	ld.w	r8,r7[-12]
800044e0:	58 18       	cp.w	r8,1
800044e2:	c1 e0       	breq	8000451e <gpio_enable_module_pin+0x62>
800044e4:	c0 63       	brcs	800044f0 <gpio_enable_module_pin+0x34>
800044e6:	58 28       	cp.w	r8,2
800044e8:	c3 20       	breq	8000454c <gpio_enable_module_pin+0x90>
800044ea:	58 38       	cp.w	r8,3
800044ec:	c4 70       	breq	8000457a <gpio_enable_module_pin+0xbe>
800044ee:	c5 d8       	rjmp	800045a8 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800044f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800044f4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800044f8:	30 19       	mov	r9,1
800044fa:	f2 08 09 48 	lsl	r8,r9,r8
800044fe:	10 99       	mov	r9,r8
80004500:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004504:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004506:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000450a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000450e:	30 19       	mov	r9,1
80004510:	f2 08 09 48 	lsl	r8,r9,r8
80004514:	10 99       	mov	r9,r8
80004516:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000451a:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000451c:	c4 88       	rjmp	800045ac <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000451e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004522:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004526:	30 19       	mov	r9,1
80004528:	f2 08 09 48 	lsl	r8,r9,r8
8000452c:	10 99       	mov	r9,r8
8000452e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004532:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80004534:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004538:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000453c:	30 19       	mov	r9,1
8000453e:	f2 08 09 48 	lsl	r8,r9,r8
80004542:	10 99       	mov	r9,r8
80004544:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004548:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
8000454a:	c3 18       	rjmp	800045ac <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000454c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004550:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004554:	30 19       	mov	r9,1
80004556:	f2 08 09 48 	lsl	r8,r9,r8
8000455a:	10 99       	mov	r9,r8
8000455c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004560:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004562:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004566:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000456a:	30 19       	mov	r9,1
8000456c:	f2 08 09 48 	lsl	r8,r9,r8
80004570:	10 99       	mov	r9,r8
80004572:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004576:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80004578:	c1 a8       	rjmp	800045ac <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000457a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000457e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004582:	30 19       	mov	r9,1
80004584:	f2 08 09 48 	lsl	r8,r9,r8
80004588:	10 99       	mov	r9,r8
8000458a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000458e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80004590:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004594:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004598:	30 19       	mov	r9,1
8000459a:	f2 08 09 48 	lsl	r8,r9,r8
8000459e:	10 99       	mov	r9,r8
800045a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045a4:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800045a6:	c0 38       	rjmp	800045ac <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
800045a8:	30 18       	mov	r8,1
800045aa:	c0 d8       	rjmp	800045c4 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800045ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045b0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800045b4:	30 19       	mov	r9,1
800045b6:	f2 08 09 48 	lsl	r8,r9,r8
800045ba:	10 99       	mov	r9,r8
800045bc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800045c0:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
800045c2:	30 08       	mov	r8,0
}
800045c4:	10 9c       	mov	r12,r8
800045c6:	2f dd       	sub	sp,-12
800045c8:	e3 cd 80 80 	ldm	sp++,r7,pc

800045cc <gpio_configure_pin>:
 *
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
800045cc:	eb cd 40 80 	pushm	r7,lr
800045d0:	1a 97       	mov	r7,sp
800045d2:	20 3d       	sub	sp,12
800045d4:	ef 4c ff f8 	st.w	r7[-8],r12
800045d8:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800045dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045e0:	a5 98       	lsr	r8,0x5
800045e2:	a9 68       	lsl	r8,0x8
800045e4:	e0 28 f0 00 	sub	r8,61440
800045e8:	ef 48 ff fc 	st.w	r7[-4],r8
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
	}

#endif
	if (flags & GPIO_PULL_UP) {
800045ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800045f0:	e2 18 00 04 	andl	r8,0x4,COH
800045f4:	c0 e0       	breq	80004610 <gpio_configure_pin+0x44>
		gpio_port->puers = 1 << (pin & 0x1F);
800045f6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800045fa:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800045fe:	30 19       	mov	r9,1
80004600:	f2 08 09 48 	lsl	r8,r9,r8
80004604:	10 99       	mov	r9,r8
80004606:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000460a:	f1 49 00 74 	st.w	r8[116],r9
8000460e:	c0 d8       	rjmp	80004628 <gpio_configure_pin+0x5c>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
80004610:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004614:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004618:	30 19       	mov	r9,1
8000461a:	f2 08 09 48 	lsl	r8,r9,r8
8000461e:	10 99       	mov	r9,r8
80004620:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004624:	f1 49 00 78 	st.w	r8[120],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80004628:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000462c:	e2 18 00 80 	andl	r8,0x80,COH
80004630:	c5 a0       	breq	800046e4 <gpio_configure_pin+0x118>
		if (flags & GPIO_BOTHEDGES) {
80004632:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004636:	e2 18 01 80 	andl	r8,0x180,COH
8000463a:	c1 a0       	breq	8000466e <gpio_configure_pin+0xa2>
			gpio_port->imr0c = 1 << (pin & 0x1F);
8000463c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004640:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004644:	30 19       	mov	r9,1
80004646:	f2 08 09 48 	lsl	r8,r9,r8
8000464a:	10 99       	mov	r9,r8
8000464c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004650:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80004654:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004658:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000465c:	30 19       	mov	r9,1
8000465e:	f2 08 09 48 	lsl	r8,r9,r8
80004662:	10 99       	mov	r9,r8
80004664:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004668:	f1 49 00 b8 	st.w	r8[184],r9
8000466c:	c3 c8       	rjmp	800046e4 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_RISING) {
8000466e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004672:	e2 18 02 80 	andl	r8,0x280,COH
80004676:	c1 a0       	breq	800046aa <gpio_configure_pin+0xde>
			gpio_port->imr0s = 1 << (pin & 0x1F);
80004678:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000467c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004680:	30 19       	mov	r9,1
80004682:	f2 08 09 48 	lsl	r8,r9,r8
80004686:	10 99       	mov	r9,r8
80004688:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000468c:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80004690:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004694:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004698:	30 19       	mov	r9,1
8000469a:	f2 08 09 48 	lsl	r8,r9,r8
8000469e:	10 99       	mov	r9,r8
800046a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046a4:	f1 49 00 b8 	st.w	r8[184],r9
800046a8:	c1 e8       	rjmp	800046e4 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_FALLING) {
800046aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046ae:	e2 18 03 80 	andl	r8,0x380,COH
800046b2:	c1 90       	breq	800046e4 <gpio_configure_pin+0x118>
			gpio_port->imr0c = 1 << (pin & 0x1F);
800046b4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046b8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046bc:	30 19       	mov	r9,1
800046be:	f2 08 09 48 	lsl	r8,r9,r8
800046c2:	10 99       	mov	r9,r8
800046c4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046c8:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
800046cc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046d0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800046d4:	30 19       	mov	r9,1
800046d6:	f2 08 09 48 	lsl	r8,r9,r8
800046da:	10 99       	mov	r9,r8
800046dc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800046e0:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
800046e4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046e8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800046ec:	5c 58       	castu.b	r8
800046ee:	c2 c0       	breq	80004746 <gpio_configure_pin+0x17a>
		if (flags & GPIO_INIT_HIGH) {
800046f0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800046f4:	e2 18 00 02 	andl	r8,0x2,COH
800046f8:	c0 e0       	breq	80004714 <gpio_configure_pin+0x148>
			gpio_port->ovrs = 1 << (pin & 0x1F);
800046fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800046fe:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004702:	30 19       	mov	r9,1
80004704:	f2 08 09 48 	lsl	r8,r9,r8
80004708:	10 99       	mov	r9,r8
8000470a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000470e:	f1 49 00 54 	st.w	r8[84],r9
80004712:	c0 d8       	rjmp	8000472c <gpio_configure_pin+0x160>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
80004714:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004718:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000471c:	30 19       	mov	r9,1
8000471e:	f2 08 09 48 	lsl	r8,r9,r8
80004722:	10 99       	mov	r9,r8
80004724:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004728:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
8000472c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004730:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004734:	30 19       	mov	r9,1
80004736:	f2 08 09 48 	lsl	r8,r9,r8
8000473a:	10 99       	mov	r9,r8
8000473c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004740:	f1 49 00 44 	st.w	r8[68],r9
80004744:	c0 d8       	rjmp	8000475e <gpio_configure_pin+0x192>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
80004746:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000474a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000474e:	30 19       	mov	r9,1
80004750:	f2 08 09 48 	lsl	r8,r9,r8
80004754:	10 99       	mov	r9,r8
80004756:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000475a:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000475e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004762:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004766:	30 19       	mov	r9,1
80004768:	f2 08 09 48 	lsl	r8,r9,r8
8000476c:	10 99       	mov	r9,r8
8000476e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004772:	91 19       	st.w	r8[0x4],r9
}
80004774:	2f dd       	sub	sp,-12
80004776:	e3 cd 80 80 	ldm	sp++,r7,pc
8000477a:	d7 03       	nop

8000477c <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
8000477c:	eb cd 40 80 	pushm	r7,lr
80004780:	1a 97       	mov	r7,sp
80004782:	20 3d       	sub	sp,12
80004784:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80004788:	fe 78 08 00 	mov	r8,-63488
8000478c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004790:	f2 09 11 03 	rsub	r9,r9,3
80004794:	28 09       	sub	r9,-128
80004796:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000479a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
8000479e:	fe 78 08 00 	mov	r8,-63488
800047a2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800047a6:	2c 09       	sub	r9,-64
800047a8:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800047ac:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800047b0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047b4:	58 08       	cp.w	r8,0
800047b6:	c1 30       	breq	800047dc <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
800047b8:	ee f9 ff f8 	ld.w	r9,r7[-8]
800047bc:	48 b8       	lddpc	r8,800047e8 <_get_interrupt_handler+0x6c>
800047be:	a1 79       	lsl	r9,0x1
800047c0:	2f f9       	sub	r9,-1
800047c2:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800047c6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047ca:	f0 08 12 00 	clz	r8,r8
800047ce:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
800047d2:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800047d4:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800047d8:	70 08       	ld.w	r8,r8[0x0]
800047da:	c0 28       	rjmp	800047de <_get_interrupt_handler+0x62>
800047dc:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800047de:	10 9c       	mov	r12,r8
800047e0:	2f dd       	sub	sp,-12
800047e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800047e6:	00 00       	add	r0,r0
800047e8:	80 00       	ld.sh	r0,r0[0x0]
800047ea:	55 b8       	stdsp	sp[0x16c],r8

800047ec <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
800047ec:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
800047f0:	fe c0 f5 f0 	sub	r0,pc,-2576

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
800047f4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
800047f8:	d5 53       	csrf	0x15
  cp      r0, r1
800047fa:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
800047fc:	31 01       	mov	r1,16
  lda.w   r2, _data_lma
800047fe:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
80004800:	c0 72       	brcc	8000480e <idata_load_loop_end>
  st.d    r0++, r4
80004802:	fe c2 f1 52 	sub	r2,pc,-3758

80004806 <idata_load_loop>:
  cp      r0, r1
  brlo    idata_load_loop
80004806:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004808:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
8000480a:	02 30       	cp.w	r0,r1
  cp      r0, r1
8000480c:	cf d3       	brcs	80004806 <idata_load_loop>

8000480e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
8000480e:	31 00       	mov	r0,16
  mov     r2, 0
80004810:	e0 61 07 38 	mov	r1,1848
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80004814:	02 30       	cp.w	r0,r1
  cp      r0, r1
80004816:	c0 62       	brcc	80004822 <udata_clear_loop_end>
  brlo    udata_clear_loop
80004818:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
8000481a:	30 03       	mov	r3,0

8000481c <udata_clear_loop>:
8000481c:	a1 22       	st.d	r0++,r2
8000481e:	02 30       	cp.w	r0,r1
80004820:	cf e3       	brcs	8000481c <udata_clear_loop>

80004822 <udata_clear_loop_end>:
80004822:	fe cf fb 76 	sub	pc,pc,-1162
80004826:	d7 03       	nop
80004828:	0c 2d       	rsub	sp,r6
8000482a:	2d 2d       	sub	sp,-184
8000482c:	2d 2d       	sub	sp,-184
8000482e:	2d 2d       	sub	sp,-184
80004830:	2d 2d       	sub	sp,-184
80004832:	2d 2d       	sub	sp,-184
80004834:	2d 2d       	sub	sp,-184
80004836:	2d 2d       	sub	sp,-184
80004838:	2d 2d       	sub	sp,-184
8000483a:	2d 2d       	sub	sp,-184
8000483c:	2d 2d       	sub	sp,-184
8000483e:	2d 2d       	sub	sp,-184
80004840:	2d 2d       	sub	sp,-184
80004842:	2d 2d       	sub	sp,-184
80004844:	2d 2d       	sub	sp,-184
80004846:	2d 2d       	sub	sp,-184
80004848:	2d 2d       	sub	sp,-184
8000484a:	2d 2d       	sub	sp,-184
8000484c:	2d 2d       	sub	sp,-184
8000484e:	2d 2d       	sub	sp,-184
80004850:	2d 2d       	sub	sp,-184
80004852:	2d 2d       	sub	sp,-184
80004854:	2d 2d       	sub	sp,-184
80004856:	2d 2d       	sub	sp,-184
80004858:	2d 2d       	sub	sp,-184
8000485a:	2d 2d       	sub	sp,-184
8000485c:	2d 2d       	sub	sp,-184
8000485e:	2d 2d       	sub	sp,-184
80004860:	2d 2d       	sub	sp,-184
80004862:	2d 2d       	sub	sp,-184
80004864:	2d 2d       	sub	sp,-184
80004866:	2d 2d       	sub	sp,-184
80004868:	2d 2d       	sub	sp,-184
8000486a:	2d 2d       	sub	sp,-184
8000486c:	2d 2d       	sub	sp,-184
8000486e:	0d 0a       	ld.w	r10,r6++
80004870:	00 00       	add	r0,r0
80004872:	00 00       	add	r0,r0
80004874:	0d 0a       	ld.w	r10,r6++
80004876:	4c 61       	lddpc	r1,8000498c <udata_clear_loop_end+0x16a>
80004878:	62 20       	ld.w	r0,r1[0x8]
8000487a:	32 20       	mov	r0,34
8000487c:	54 61       	stdsp	sp[0x118],r1
8000487e:	73 6b       	ld.w	r11,r9[0x58]
80004880:	20 32       	sub	r2,3
80004882:	20 2d       	sub	sp,8
80004884:	20 45       	sub	r5,4
80004886:	72 6c       	ld.w	r12,r9[0x18]
80004888:	65 6e       	ld.w	lr,r2[0x58]
8000488a:	64 20       	ld.w	r0,r2[0x8]
8000488c:	52 2e       	stdsp	sp[0x88],lr
8000488e:	20 4d       	sub	sp,16
80004890:	79 6b       	ld.w	r11,r12[0x58]
80004892:	6c 65       	ld.w	r5,r6[0x18]
80004894:	62 75       	ld.w	r5,r1[0x1c]
80004896:	73 74       	ld.w	r4,r9[0x5c]
80004898:	0d 0a       	ld.w	r10,r6++
8000489a:	00 00       	add	r0,r0
8000489c:	0d 0a       	ld.w	r10,r6++
8000489e:	2d 2d       	sub	sp,-184
800048a0:	2d 2d       	sub	sp,-184
800048a2:	2d 2d       	sub	sp,-184
800048a4:	2d 2d       	sub	sp,-184
800048a6:	2d 2d       	sub	sp,-184
800048a8:	2d 2d       	sub	sp,-184
800048aa:	2d 2d       	sub	sp,-184
800048ac:	2d 2d       	sub	sp,-184
800048ae:	2d 2d       	sub	sp,-184
800048b0:	2d 2d       	sub	sp,-184
800048b2:	2d 2d       	sub	sp,-184
800048b4:	2d 2d       	sub	sp,-184
800048b6:	2d 2d       	sub	sp,-184
800048b8:	2d 2d       	sub	sp,-184
800048ba:	2d 2d       	sub	sp,-184
800048bc:	2d 2d       	sub	sp,-184
800048be:	2d 2d       	sub	sp,-184
800048c0:	2d 2d       	sub	sp,-184
800048c2:	2d 2d       	sub	sp,-184
800048c4:	2d 2d       	sub	sp,-184
800048c6:	2d 2d       	sub	sp,-184
800048c8:	2d 2d       	sub	sp,-184
800048ca:	2d 2d       	sub	sp,-184
800048cc:	2d 2d       	sub	sp,-184
800048ce:	2d 2d       	sub	sp,-184
800048d0:	2d 2d       	sub	sp,-184
800048d2:	2d 2d       	sub	sp,-184
800048d4:	2d 2d       	sub	sp,-184
800048d6:	2d 2d       	sub	sp,-184
800048d8:	2d 2d       	sub	sp,-184
800048da:	2d 2d       	sub	sp,-184
800048dc:	2d 2d       	sub	sp,-184
800048de:	2d 2d       	sub	sp,-184
800048e0:	2d 2d       	sub	sp,-184
800048e2:	2d 0d       	sub	sp,-192
800048e4:	0a 00       	add	r0,r5
800048e6:	00 00       	add	r0,r0
800048e8:	0d 0a       	ld.w	r10,r6++
800048ea:	53 44       	stdsp	sp[0xd0],r4
800048ec:	52 41       	stdsp	sp[0x90],r1
800048ee:	4d 20       	lddpc	r0,80004a34 <udata_clear_loop_end+0x212>
800048f0:	73 69       	ld.w	r9,r9[0x58]
800048f2:	7a 65       	ld.w	r5,sp[0x18]
800048f4:	3a 20       	mov	r0,-94
800048f6:	00 00       	add	r0,r0
800048f8:	20 4d       	sub	sp,16
800048fa:	42 0d       	lddsp	sp,sp[0x80]
800048fc:	0a 00       	add	r0,r5
800048fe:	00 00       	add	r0,r0
80004900:	53 44       	stdsp	sp[0xd0],r4
80004902:	52 41       	stdsp	sp[0x90],r1
80004904:	4d 20       	lddpc	r0,80004a4c <sd_mmc_spi_write_open_PDCA+0x10>
80004906:	69 6e       	ld.w	lr,r4[0x58]
80004908:	69 74       	ld.w	r4,r4[0x5c]
8000490a:	69 61       	ld.w	r1,r4[0x58]
8000490c:	6c 69       	ld.w	r9,r6[0x18]
8000490e:	7a 65       	ld.w	r5,sp[0x18]
80004910:	64 0d       	ld.w	sp,r2[0x0]
80004912:	0a 0a       	add	r10,r5
80004914:	00 00       	add	r0,r0
80004916:	00 00       	add	r0,r0
80004918:	0d 46       	ld.w	r6,--r6
8000491a:	69 6c       	ld.w	r12,r4[0x58]
8000491c:	6c 69       	ld.w	r9,r6[0x18]
8000491e:	6e 67       	ld.w	r7,r7[0x18]
80004920:	20 53       	sub	r3,5
80004922:	44 52       	lddsp	r2,sp[0x114]
80004924:	41 4d       	lddsp	sp,sp[0x50]
80004926:	20 77       	sub	r7,7
80004928:	69 74       	ld.w	r4,r4[0x5c]
8000492a:	68 20       	ld.w	r0,r4[0x8]
8000492c:	74 65       	ld.w	r5,r10[0x18]
8000492e:	73 74       	ld.w	r4,r9[0x5c]
80004930:	20 70       	sub	r0,7
80004932:	61 74       	ld.w	r4,r0[0x5c]
80004934:	74 65       	ld.w	r5,r10[0x18]
80004936:	72 6e       	ld.w	lr,r9[0x18]
80004938:	3a 20       	mov	r0,-94
8000493a:	00 00       	add	r0,r0
8000493c:	0d 0a       	ld.w	r10,r6++
8000493e:	53 44       	stdsp	sp[0xd0],r4
80004940:	52 41       	stdsp	sp[0x90],r1
80004942:	4d 20       	lddpc	r0,80004a88 <sd_mmc_spi_write_open_PDCA+0x4c>
80004944:	66 69       	ld.w	r9,r3[0x18]
80004946:	6c 6c       	ld.w	r12,r6[0x18]
80004948:	65 64       	ld.w	r4,r2[0x58]
8000494a:	20 77       	sub	r7,7
8000494c:	69 74       	ld.w	r4,r4[0x5c]
8000494e:	68 20       	ld.w	r0,r4[0x8]
80004950:	74 65       	ld.w	r5,r10[0x18]
80004952:	73 74       	ld.w	r4,r9[0x5c]
80004954:	20 70       	sub	r0,7
80004956:	61 74       	ld.w	r4,r0[0x5c]
80004958:	74 65       	ld.w	r5,r10[0x18]
8000495a:	72 6e       	ld.w	lr,r9[0x18]
8000495c:	3a 20       	mov	r0,-94
8000495e:	30 78       	mov	r8,7
80004960:	30 30       	mov	r0,3
80004962:	2c 20       	sub	r0,-62
80004964:	30 78       	mov	r8,7
80004966:	30 31       	mov	r1,3
80004968:	20 2e       	sub	lr,2
8000496a:	2e 2e       	sub	lr,-30
8000496c:	20 30       	sub	r0,3
8000496e:	78 46       	ld.w	r6,r12[0x10]
80004970:	46 0d       	lddsp	sp,sp[0x180]
80004972:	0a 00       	add	r0,r5
80004974:	0d 0a       	ld.w	r10,r6++
80004976:	49 6e       	lddpc	lr,800049cc <udata_clear_loop_end+0x1aa>
80004978:	73 65       	ld.w	r5,r9[0x58]
8000497a:	72 74       	ld.w	r4,r9[0x1c]
8000497c:	20 53       	sub	r3,5
8000497e:	44 2f       	lddsp	pc,sp[0x108]
80004980:	4d 4d       	lddpc	sp,80004ad0 <sd_mmc_spi_write_close_PDCA>
80004982:	43 2e       	lddsp	lr,sp[0xc8]
80004984:	2e 2e       	sub	lr,-30
80004986:	00 00       	add	r0,r0
80004988:	0d 0a       	ld.w	r10,r6++
8000498a:	43 61       	lddsp	r1,sp[0xd8]
8000498c:	72 64       	ld.w	r4,r9[0x18]
8000498e:	20 64       	sub	r4,6
80004990:	65 74       	ld.w	r4,r2[0x5c]
80004992:	65 63       	ld.w	r3,r2[0x58]
80004994:	74 65       	ld.w	r5,r10[0x18]
80004996:	64 21       	ld.w	r1,r2[0x8]
80004998:	00 00       	add	r0,r0
8000499a:	00 00       	add	r0,r0
8000499c:	0d 0a       	ld.w	r10,r6++
8000499e:	43 61       	lddsp	r1,sp[0xd8]
800049a0:	70 61       	ld.w	r1,r8[0x18]
800049a2:	63 69       	ld.w	r9,r1[0x58]
800049a4:	74 79       	ld.w	r9,r10[0x1c]
800049a6:	20 3d       	sub	sp,12
800049a8:	20 00       	sub	r0,0
800049aa:	00 00       	add	r0,r0
800049ac:	20 4d       	sub	sp,16
800049ae:	42 79       	lddsp	r9,sp[0x9c]
800049b0:	74 65       	ld.w	r5,r10[0x18]
800049b2:	73 0d       	ld.w	sp,r9[0x40]
800049b4:	0a 0a       	add	r10,r5
800049b6:	00 00       	add	r0,r0
800049b8:	0d 54       	ld.sh	r4,--r6
800049ba:	72 61       	ld.w	r1,r9[0x18]
800049bc:	6e 73       	ld.w	r3,r7[0x1c]
800049be:	66 65       	ld.w	r5,r3[0x18]
800049c0:	72 69       	ld.w	r9,r9[0x18]
800049c2:	6e 67       	ld.w	r7,r7[0x18]
800049c4:	20 53       	sub	r3,5
800049c6:	44 52       	lddsp	r2,sp[0x114]
800049c8:	41 4d       	lddsp	sp,sp[0x50]
800049ca:	20 74       	sub	r4,7
800049cc:	6f 20       	ld.w	r0,r7[0x48]
800049ce:	53 44       	stdsp	sp[0xd0],r4
800049d0:	2f 4d       	sub	sp,-48
800049d2:	4d 43       	lddpc	r3,80004b20 <sd_mmc_spi_write_close_PDCA+0x50>
800049d4:	3a 20       	mov	r0,-94
800049d6:	00 00       	add	r0,r0
800049d8:	0d 0a       	ld.w	r10,r6++
800049da:	54 72       	stdsp	sp[0x11c],r2
800049dc:	61 6e       	ld.w	lr,r0[0x58]
800049de:	73 66       	ld.w	r6,r9[0x58]
800049e0:	65 72       	ld.w	r2,r2[0x5c]
800049e2:	20 63       	sub	r3,6
800049e4:	6f 6d       	ld.w	sp,r7[0x58]
800049e6:	70 6c       	ld.w	r12,r8[0x18]
800049e8:	65 74       	ld.w	r4,r2[0x5c]
800049ea:	65 21       	ld.w	r1,r2[0x48]
800049ec:	00 00       	add	r0,r0
800049ee:	00 00       	add	r0,r0
800049f0:	0d 0a       	ld.w	r10,r6++
800049f2:	59 6f       	cp.w	pc,22
800049f4:	75 20       	ld.w	r0,r10[0x48]
800049f6:	63 61       	ld.w	r1,r1[0x58]
800049f8:	6e 20       	ld.w	r0,r7[0x8]
800049fa:	6e 6f       	ld.w	pc,r7[0x18]
800049fc:	77 20       	ld.w	r0,r11[0x48]
800049fe:	70 6f       	ld.w	pc,r8[0x18]
80004a00:	77 65       	ld.w	r5,r11[0x58]
80004a02:	72 20       	ld.w	r0,r9[0x8]
80004a04:	64 6f       	ld.w	pc,r2[0x18]
80004a06:	77 6e       	ld.w	lr,r11[0x58]
80004a08:	20 74       	sub	r4,7
80004a0a:	68 65       	ld.w	r5,r4[0x18]
80004a0c:	20 62       	sub	r2,6
80004a0e:	6f 61       	ld.w	r1,r7[0x58]
80004a10:	72 64       	ld.w	r4,r9[0x18]
80004a12:	20 61       	sub	r1,6
80004a14:	6e 64       	ld.w	r4,r7[0x18]
80004a16:	20 63       	sub	r3,6
80004a18:	68 65       	ld.w	r5,r4[0x18]
80004a1a:	63 6b       	ld.w	r11,r1[0x58]
80004a1c:	20 74       	sub	r4,7
80004a1e:	68 65       	ld.w	r5,r4[0x18]
80004a20:	20 63       	sub	r3,6
80004a22:	6f 6e       	ld.w	lr,r7[0x58]
80004a24:	74 65       	ld.w	r5,r10[0x18]
80004a26:	6e 74       	ld.w	r4,r7[0x1c]
80004a28:	73 20       	ld.w	r0,r9[0x48]
80004a2a:	6f 66       	ld.w	r6,r7[0x58]
80004a2c:	20 74       	sub	r4,7
80004a2e:	68 65       	ld.w	r5,r4[0x18]
80004a30:	20 53       	sub	r3,5
80004a32:	44 2f       	lddsp	pc,sp[0x108]
80004a34:	4d 4d       	lddpc	sp,80004b84 <sd_mmc_spi_write_close_PDCA+0xb4>
80004a36:	43 0d       	lddsp	sp,sp[0xc0]
80004a38:	0a 00       	add	r0,r5
	...

80004a3c <sd_mmc_spi_write_open_PDCA>:
//!
//! @return bit
//!   The open succeeded      -> Ture
//!/
static Bool sd_mmc_spi_write_open_PDCA (uint32_t pos)
{
80004a3c:	eb cd 40 80 	pushm	r7,lr
80004a40:	1a 97       	mov	r7,sp
80004a42:	20 3d       	sub	sp,12
80004a44:	ef 4c ff f4 	st.w	r7[-12],r12
	uint32_t	gl_ptr_mem;
	uint8_t		r1;
	
	
	// Set the global memory ptr at a Byte address.
	gl_ptr_mem = pos << 9;                    // gl_ptr_mem = pos * 512
80004a48:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004a4c:	a9 78       	lsl	r8,0x9
80004a4e:	ef 48 ff f8 	st.w	r7[-8],r8

	// wait for MMC not busy
	if (false == sd_mmc_spi_wait_not_busy())
80004a52:	f0 1f 00 1b 	mcall	80004abc <sd_mmc_spi_write_open_PDCA+0x80>
80004a56:	18 98       	mov	r8,r12
80004a58:	ec 18 00 01 	eorl	r8,0x1
80004a5c:	5c 58       	castu.b	r8
80004a5e:	c0 30       	breq	80004a64 <sd_mmc_spi_write_open_PDCA+0x28>
	return false;
80004a60:	30 08       	mov	r8,0
80004a62:	c2 88       	rjmp	80004ab2 <sd_mmc_spi_write_open_PDCA+0x76>


	spi_selectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);          // select SD_MMC_SPI
80004a64:	30 1b       	mov	r11,1
80004a66:	fe 7c 28 00 	mov	r12,-55296
80004a6a:	f0 1f 00 16 	mcall	80004ac0 <sd_mmc_spi_write_open_PDCA+0x84>
	// issue command
	r1 = sd_mmc_spi_command(MMC_WRITE_BLOCK, gl_ptr_mem);
80004a6e:	ee fb ff f8 	ld.w	r11,r7[-8]
80004a72:	31 8c       	mov	r12,24
80004a74:	f0 1f 00 14 	mcall	80004ac4 <sd_mmc_spi_write_open_PDCA+0x88>
80004a78:	18 98       	mov	r8,r12
80004a7a:	ef 68 ff ff 	st.b	r7[-1],r8

	// check for valid response
	if (r1 != 0x00)
80004a7e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004a82:	30 08       	mov	r8,0
80004a84:	f0 09 18 00 	cp.b	r9,r8
80004a88:	c0 80       	breq	80004a98 <sd_mmc_spi_write_open_PDCA+0x5c>
	{
		spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80004a8a:	30 1b       	mov	r11,1
80004a8c:	fe 7c 28 00 	mov	r12,-55296
80004a90:	f0 1f 00 0e 	mcall	80004ac8 <sd_mmc_spi_write_open_PDCA+0x8c>
		// print_dbg("\n****** could not open SD_MMC_SPI for single block read\n");
		// Trace("\n****** could not open SD_MMC_SPI for single block read\n");
		return false;
80004a94:	30 08       	mov	r8,0
80004a96:	c0 e8       	rjmp	80004ab2 <sd_mmc_spi_write_open_PDCA+0x76>
	}

	// send dummy
	spi_write(SD_MMC_SPI,0xFF);   // give clock again to end transaction
80004a98:	e0 6b 00 ff 	mov	r11,255
80004a9c:	fe 7c 28 00 	mov	r12,-55296
80004aa0:	f0 1f 00 0b 	mcall	80004acc <sd_mmc_spi_write_open_PDCA+0x90>

	// send data start token
	spi_write(SD_MMC_SPI,MMC_STARTBLOCK_WRITE);
80004aa4:	e0 6b 00 fe 	mov	r11,254
80004aa8:	fe 7c 28 00 	mov	r12,-55296
80004aac:	f0 1f 00 08 	mcall	80004acc <sd_mmc_spi_write_open_PDCA+0x90>

	return true;   // Read done.
80004ab0:	30 18       	mov	r8,1
}
80004ab2:	10 9c       	mov	r12,r8
80004ab4:	2f dd       	sub	sp,-12
80004ab6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004aba:	00 00       	add	r0,r0
80004abc:	80 00       	ld.sh	r0,r0[0x0]
80004abe:	29 d8       	sub	r8,-99
80004ac0:	80 00       	ld.sh	r0,r0[0x0]
80004ac2:	3a 90       	mov	r0,-87
80004ac4:	80 00       	ld.sh	r0,r0[0x0]
80004ac6:	23 ac       	sub	r12,58
80004ac8:	80 00       	ld.sh	r0,r0[0x0]
80004aca:	3b 28       	mov	r8,-78
80004acc:	80 00       	ld.sh	r0,r0[0x0]
80004ace:	3d 32       	mov	r2,-45

80004ad0 <sd_mmc_spi_write_close_PDCA>:
//! Stop PDCA transfer
//! @brief This function closes a PDCA write transfer
//! page programming.
//!
static Bool sd_mmc_spi_write_close_PDCA (void)
{
80004ad0:	eb cd 40 80 	pushm	r7,lr
80004ad4:	1a 97       	mov	r7,sp
80004ad6:	20 1d       	sub	sp,4
	uint16_t	i;
	uint8_t		r1;

	// load 16-bit CRC (ignored)
	spi_write(SD_MMC_SPI,0xFF);
80004ad8:	e0 6b 00 ff 	mov	r11,255
80004adc:	fe 7c 28 00 	mov	r12,-55296
80004ae0:	f0 1f 00 2b 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>
	spi_write(SD_MMC_SPI,0xFF);
80004ae4:	e0 6b 00 ff 	mov	r11,255
80004ae8:	fe 7c 28 00 	mov	r12,-55296
80004aec:	f0 1f 00 28 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>

	// read data response token
	r1 = sd_mmc_spi_send_and_read(0xFF);
80004af0:	e0 6c 00 ff 	mov	r12,255
80004af4:	f0 1f 00 27 	mcall	80004b90 <sd_mmc_spi_write_close_PDCA+0xc0>
80004af8:	18 98       	mov	r8,r12
80004afa:	ef 68 ff ff 	st.b	r7[-1],r8
	if( (r1 & MMC_DR_MASK) != MMC_DR_ACCEPT)
80004afe:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004b02:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80004b06:	58 58       	cp.w	r8,5
80004b08:	c1 40       	breq	80004b30 <sd_mmc_spi_write_close_PDCA+0x60>
	{
		spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80004b0a:	e0 6b 00 ff 	mov	r11,255
80004b0e:	fe 7c 28 00 	mov	r12,-55296
80004b12:	f0 1f 00 1f 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>
		spi_write(SD_MMC_SPI,0xFF);
80004b16:	e0 6b 00 ff 	mov	r11,255
80004b1a:	fe 7c 28 00 	mov	r12,-55296
80004b1e:	f0 1f 00 1c 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>
		spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);
80004b22:	30 1b       	mov	r11,1
80004b24:	fe 7c 28 00 	mov	r12,-55296
80004b28:	f0 1f 00 1b 	mcall	80004b94 <sd_mmc_spi_write_close_PDCA+0xc4>
		return false;
80004b2c:	30 08       	mov	r8,0
80004b2e:	c2 b8       	rjmp	80004b84 <sd_mmc_spi_write_close_PDCA+0xb4>
		//     return r1;             // return ERROR byte
	}

	spi_write(SD_MMC_SPI,0xFF);    // send dummy bytes
80004b30:	e0 6b 00 ff 	mov	r11,255
80004b34:	fe 7c 28 00 	mov	r12,-55296
80004b38:	f0 1f 00 15 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>
	spi_write(SD_MMC_SPI,0xFF);
80004b3c:	e0 6b 00 ff 	mov	r11,255
80004b40:	fe 7c 28 00 	mov	r12,-55296
80004b44:	f0 1f 00 12 	mcall	80004b8c <sd_mmc_spi_write_close_PDCA+0xbc>

	// release chip select
	spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI
80004b48:	30 1b       	mov	r11,1
80004b4a:	fe 7c 28 00 	mov	r12,-55296
80004b4e:	f0 1f 00 12 	mcall	80004b94 <sd_mmc_spi_write_close_PDCA+0xc4>

	// wait card not busy after last programming operation
	i=0;
80004b52:	30 08       	mov	r8,0
80004b54:	ef 58 ff fc 	st.h	r7[-4],r8
	while (false == sd_mmc_spi_wait_not_busy())
80004b58:	c0 e8       	rjmp	80004b74 <sd_mmc_spi_write_close_PDCA+0xa4>
	{
		i++;
80004b5a:	ef 08 ff fc 	ld.sh	r8,r7[-4]
80004b5e:	2f f8       	sub	r8,-1
80004b60:	ef 58 ff fc 	st.h	r7[-4],r8
		if (i == 10)
80004b64:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80004b68:	30 a8       	mov	r8,10
80004b6a:	f0 09 19 00 	cp.h	r9,r8
80004b6e:	c0 31       	brne	80004b74 <sd_mmc_spi_write_close_PDCA+0xa4>
		return false;
80004b70:	30 08       	mov	r8,0
80004b72:	c0 98       	rjmp	80004b84 <sd_mmc_spi_write_close_PDCA+0xb4>
	// release chip select
	spi_unselectChip(SD_MMC_SPI, SD_MMC_SPI_NPCS);  // unselect SD_MMC_SPI

	// wait card not busy after last programming operation
	i=0;
	while (false == sd_mmc_spi_wait_not_busy())
80004b74:	f0 1f 00 09 	mcall	80004b98 <sd_mmc_spi_write_close_PDCA+0xc8>
80004b78:	18 98       	mov	r8,r12
80004b7a:	ec 18 00 01 	eorl	r8,0x1
80004b7e:	5c 58       	castu.b	r8
80004b80:	ce d1       	brne	80004b5a <sd_mmc_spi_write_close_PDCA+0x8a>
		i++;
		if (i == 10)
		return false;
	}

	return true;                  // Write done
80004b82:	30 18       	mov	r8,1
}
80004b84:	10 9c       	mov	r12,r8
80004b86:	2f fd       	sub	sp,-4
80004b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80004b8c:	80 00       	ld.sh	r0,r0[0x0]
80004b8e:	3d 32       	mov	r2,-45
80004b90:	80 00       	ld.sh	r0,r0[0x0]
80004b92:	24 bc       	sub	r12,75
80004b94:	80 00       	ld.sh	r0,r0[0x0]
80004b96:	3b 28       	mov	r8,-78
80004b98:	80 00       	ld.sh	r0,r0[0x0]
80004b9a:	29 d8       	sub	r8,-99

80004b9c <local_pdca_init>:
volatile unsigned long *sdram = SDRAM;



static void local_pdca_init(void)
{
80004b9c:	eb cd 40 80 	pushm	r7,lr
80004ba0:	1a 97       	mov	r7,sp
80004ba2:	20 cd       	sub	sp,48
		.size = 512,                              // transfer counter: here the size of the string
		.r_addr = NULL,                           // next memory address after 1st transfer complete
		.r_size = 0,                              // next transfer counter not used here
		.pid = AVR32_PDCA_CHANNEL_USED_RX,        // select peripheral ID - data are on reception from SPI1 RX line
		.transfer_size = PDCA_TRANSFER_SIZE_BYTE  // select size of the transfer: 8,16,32 bits
	};
80004ba4:	49 99       	lddpc	r9,80004c08 <local_pdca_init+0x6c>
80004ba6:	ee c8 00 18 	sub	r8,r7,24
80004baa:	f2 ea 00 00 	ld.d	r10,r9[0]
80004bae:	f0 eb 00 00 	st.d	r8[0],r10
80004bb2:	f2 ea 00 08 	ld.d	r10,r9[8]
80004bb6:	f0 eb 00 08 	st.d	r8[8],r10
80004bba:	f2 ea 00 10 	ld.d	r10,r9[16]
80004bbe:	f0 eb 00 10 	st.d	r8[16],r10
		.size = 512,                              // transfer counter: here the size of the string
		.r_addr = NULL,                           // next memory address after 1st transfer complete
		.r_size = 0,                              // next transfer counter not used here
		.pid = AVR32_PDCA_CHANNEL_USED_TX,        // select peripheral ID - data are on reception from SPI1 RX line
		.transfer_size = PDCA_TRANSFER_SIZE_WORD  // select size of the transfer: 8,16,32 bits
	};
80004bc2:	49 38       	lddpc	r8,80004c0c <local_pdca_init+0x70>
80004bc4:	70 08       	ld.w	r8,r8[0x0]
80004bc6:	ef 48 ff d0 	st.w	r7[-48],r8
80004bca:	e0 68 02 00 	mov	r8,512
80004bce:	ef 48 ff d4 	st.w	r7[-44],r8
80004bd2:	30 08       	mov	r8,0
80004bd4:	ef 48 ff d8 	st.w	r7[-40],r8
80004bd8:	30 08       	mov	r8,0
80004bda:	ef 48 ff dc 	st.w	r7[-36],r8
80004bde:	31 08       	mov	r8,16
80004be0:	ef 48 ff e0 	st.w	r7[-32],r8
80004be4:	30 28       	mov	r8,2
80004be6:	ef 48 ff e4 	st.w	r7[-28],r8

	// Init PDCA transmission channel
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_TX, &pdca_options_SPI_TX);
80004bea:	ee c8 00 30 	sub	r8,r7,48
80004bee:	10 9b       	mov	r11,r8
80004bf0:	30 1c       	mov	r12,1
80004bf2:	f0 1f 00 08 	mcall	80004c10 <local_pdca_init+0x74>

	// Init PDCA Reception channel
	pdca_init_channel(AVR32_PDCA_CHANNEL_SPI_RX, &pdca_options_SPI_RX);
80004bf6:	ee c8 00 18 	sub	r8,r7,24
80004bfa:	10 9b       	mov	r11,r8
80004bfc:	30 0c       	mov	r12,0
80004bfe:	f0 1f 00 05 	mcall	80004c10 <local_pdca_init+0x74>
}
80004c02:	2f 4d       	sub	sp,-48
80004c04:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c08:	80 00       	ld.sh	r0,r0[0x0]
80004c0a:	56 98       	stdsp	sp[0x1a4],r8
80004c0c:	00 00       	add	r0,r0
80004c0e:	00 08       	add	r8,r0
80004c10:	80 00       	ld.sh	r0,r0[0x0]
80004c12:	36 b4       	mov	r4,107

80004c14 <sd_mmc_resources_init>:


static void sd_mmc_resources_init(void)
{
80004c14:	eb cd 40 80 	pushm	r7,lr
80004c18:	1a 97       	mov	r7,sp
80004c1a:	20 4d       	sub	sp,16
		.spck_delay   = 0,
		.trans_delay  = 0,
		.stay_act     = 1,
		.spi_mode     = 0,
		.modfdis      = 1
	};
80004c1c:	49 d8       	lddpc	r8,80004c90 <sd_mmc_resources_init+0x7c>
80004c1e:	ee ca 00 10 	sub	r10,r7,16
80004c22:	10 9b       	mov	r11,r8
80004c24:	f6 e8 00 00 	ld.d	r8,r11[0]
80004c28:	f4 e9 00 00 	st.d	r10[0],r8
80004c2c:	f6 e8 00 08 	ld.d	r8,r11[8]
80004c30:	f4 e9 00 08 	st.d	r10[8],r8

	// Assign I/Os to SPI.
	gpio_enable_module(SD_MMC_SPI_GPIO_MAP,
80004c34:	30 4b       	mov	r11,4
80004c36:	49 8c       	lddpc	r12,80004c94 <sd_mmc_resources_init+0x80>
80004c38:	f0 1f 00 18 	mcall	80004c98 <sd_mmc_resources_init+0x84>
	sizeof(SD_MMC_SPI_GPIO_MAP) / sizeof(SD_MMC_SPI_GPIO_MAP[0]));

	// Initialize as master.
	spi_initMaster(SD_MMC_SPI, &spiOptions);
80004c3c:	ee c8 00 10 	sub	r8,r7,16
80004c40:	10 9b       	mov	r11,r8
80004c42:	fe 7c 28 00 	mov	r12,-55296
80004c46:	f0 1f 00 16 	mcall	80004c9c <sd_mmc_resources_init+0x88>

	// Set SPI selection mode: variable_ps, pcs_decode, delay.
	spi_selectionMode(SD_MMC_SPI, 0, 0, 0);
80004c4a:	30 09       	mov	r9,0
80004c4c:	30 0a       	mov	r10,0
80004c4e:	30 0b       	mov	r11,0
80004c50:	fe 7c 28 00 	mov	r12,-55296
80004c54:	f0 1f 00 13 	mcall	80004ca0 <sd_mmc_resources_init+0x8c>

	// Enable SPI module.
	spi_enable(SD_MMC_SPI);
80004c58:	fe 7c 28 00 	mov	r12,-55296
80004c5c:	f0 1f 00 12 	mcall	80004ca4 <sd_mmc_resources_init+0x90>

	// Initialize SD/MMC driver with SPI clock (PBA).
	sd_mmc_spi_init(spiOptions, PBA_HZ);
80004c60:	20 4d       	sub	sp,16
80004c62:	1a 98       	mov	r8,sp
80004c64:	10 9a       	mov	r10,r8
80004c66:	ee cb 00 10 	sub	r11,r7,16
80004c6a:	f6 e8 00 00 	ld.d	r8,r11[0]
80004c6e:	f4 e9 00 00 	st.d	r10[0],r8
80004c72:	f6 e8 00 08 	ld.d	r8,r11[8]
80004c76:	f4 e9 00 08 	st.d	r10[8],r8
80004c7a:	e0 6c c3 80 	mov	r12,50048
80004c7e:	ea 1c 01 c9 	orh	r12,0x1c9
80004c82:	f0 1f 00 0a 	mcall	80004ca8 <sd_mmc_resources_init+0x94>
80004c86:	2f cd       	sub	sp,-16
}
80004c88:	2f cd       	sub	sp,-16
80004c8a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c8e:	00 00       	add	r0,r0
80004c90:	80 00       	ld.sh	r0,r0[0x0]
80004c92:	56 68       	stdsp	sp[0x198],r8
80004c94:	80 00       	ld.sh	r0,r0[0x0]
80004c96:	56 78       	stdsp	sp[0x19c],r8
80004c98:	80 00       	ld.sh	r0,r0[0x0]
80004c9a:	44 4c       	lddsp	r12,sp[0x110]
80004c9c:	80 00       	ld.sh	r0,r0[0x0]
80004c9e:	39 68       	mov	r8,-106
80004ca0:	80 00       	ld.sh	r0,r0[0x0]
80004ca2:	39 fc       	mov	r12,-97
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	3d 18       	mov	r8,-47
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	23 14       	sub	r4,49

80004cac <main>:

int main (void)
{
80004cac:	eb cd 40 8c 	pushm	r2-r3,r7,lr
80004cb0:	1a 97       	mov	r7,sp
80004cb2:	20 ad       	sub	sp,40
	pm_freq_param_t System_Clock = {
		.cpu_f = CPU_HZ,
		.pba_f = PBA_HZ,
		.osc0_f = FOSC0,
		.osc0_startup = OSC0_STARTUP
	};
80004cb4:	fe f8 02 64 	ld.w	r8,pc[612]
80004cb8:	ee ca 00 28 	sub	r10,r7,40
80004cbc:	10 9b       	mov	r11,r8
80004cbe:	f6 e8 00 00 	ld.d	r8,r11[0]
80004cc2:	f4 e9 00 00 	st.d	r10[0],r8
80004cc6:	f6 e8 00 08 	ld.d	r8,r11[8]
80004cca:	f4 e9 00 08 	st.d	r10[8],r8
	pm_configure_clocks(&System_Clock);
80004cce:	ee c8 00 28 	sub	r8,r7,40
80004cd2:	10 9c       	mov	r12,r8
80004cd4:	f0 1f 00 92 	mcall	80004f1c <main+0x270>
	
	// Initialize debug RS232 with PBA clock
	init_dbg_rs232(PBA_HZ);
80004cd8:	e0 6c c3 80 	mov	r12,50048
80004cdc:	ea 1c 01 c9 	orh	r12,0x1c9
80004ce0:	f0 1f 00 90 	mcall	80004f20 <main+0x274>

	// Initialize the EVK1100 and its PIN config
	board_init();
80004ce4:	f0 1f 00 90 	mcall	80004f24 <main+0x278>
	
	// Initialize SD/MMC driver resources: GPIO, SPI and SD/MMC.
	sd_mmc_resources_init();
80004ce8:	f0 1f 00 90 	mcall	80004f28 <main+0x27c>
	
	// Write start string to USART
	print_dbg("\x0C---------------------------------------------------------------------\r\n");
80004cec:	fe fc 02 40 	ld.w	r12,pc[576]
80004cf0:	f0 1f 00 90 	mcall	80004f30 <main+0x284>
	print_dbg("\r\nLab 2 Task 2 - Erlend R. Myklebust\r\n");
80004cf4:	fe fc 02 40 	ld.w	r12,pc[576]
80004cf8:	f0 1f 00 8e 	mcall	80004f30 <main+0x284>
	print_dbg("\r\n---------------------------------------------------------------------\r\n");
80004cfc:	fe fc 02 3c 	ld.w	r12,pc[572]
80004d00:	f0 1f 00 8c 	mcall	80004f30 <main+0x284>
	// The SDRAM is 32 MB in total, meaning:
	// Number of bits = 268,435,456
	// Number of bytes = 33,554,432
	// Number of 4 byte words = 8,388,608
	// Defining SDRAM size in 32-bit words and write to USART:
	sdram_size = SDRAM_SIZE >> 2;
80004d04:	fc 18 00 80 	movh	r8,0x80
80004d08:	ef 48 ff f0 	st.w	r7[-16],r8
	print_dbg("\r\nSDRAM size: ");
80004d0c:	fe fc 02 30 	ld.w	r12,pc[560]
80004d10:	f0 1f 00 88 	mcall	80004f30 <main+0x284>
	print_dbg_ulong(SDRAM_SIZE >> 20);
80004d14:	32 0c       	mov	r12,32
80004d16:	f0 1f 00 8b 	mcall	80004f40 <main+0x294>
	print_dbg(" MB\r\n");
80004d1a:	fe fc 02 2a 	ld.w	r12,pc[554]
80004d1e:	f0 1f 00 85 	mcall	80004f30 <main+0x284>
	
	// Initialize the external SDRAM chip.
	sdramc_init(CPU_HZ);
80004d22:	e0 6c 87 00 	mov	r12,34560
80004d26:	ea 1c 03 93 	orh	r12,0x393
80004d2a:	f0 1f 00 88 	mcall	80004f48 <main+0x29c>
	print_dbg("SDRAM initialized\r\n\n");	
80004d2e:	fe fc 02 1e 	ld.w	r12,pc[542]
80004d32:	f0 1f 00 80 	mcall	80004f30 <main+0x284>
	
	// Setting EBI slave to have a fixed default master
	AVR32_HMATRIX.SCFG[AVR32_HMATRIX_SLAVE_EBI].defmstr_type	= AVR32_HMATRIX_DEFMSTR_TYPE_FIXED_DEFAULT;
80004d36:	fe 69 10 00 	mov	r9,-126976
80004d3a:	73 58       	ld.w	r8,r9[0x54]
80004d3c:	30 2a       	mov	r10,2
80004d3e:	f1 da d2 02 	bfins	r8,r10,0x10,0x2
80004d42:	f3 48 00 54 	st.w	r9[84],r8

	// Set EBI slave to have PDCA as master
	AVR32_HMATRIX.SCFG[AVR32_HMATRIX_SLAVE_EBI].fixed_defmstr	= AVR32_HMATRIX_MASTER_PDCA;
80004d46:	fe 69 10 00 	mov	r9,-126976
80004d4a:	73 58       	ld.w	r8,r9[0x54]
80004d4c:	30 3a       	mov	r10,3
80004d4e:	f1 da d2 44 	bfins	r8,r10,0x12,0x4
80004d52:	f3 48 00 54 	st.w	r9[84],r8
	
	// Determine the increment of steps for progress indicator
	progress_inc = (sdram_size + 50) / 100;
80004d56:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004d5a:	f0 c9 ff ce 	sub	r9,r8,-50
80004d5e:	e0 68 85 1f 	mov	r8,34079
80004d62:	ea 18 51 eb 	orh	r8,0x51eb
80004d66:	f2 08 06 48 	mulu.d	r8,r9,r8
80004d6a:	f2 08 16 05 	lsr	r8,r9,0x5
80004d6e:	ef 48 ff ec 	st.w	r7[-20],r8
	
	// Fill SDRAM with test pattern: 0x00, 0x01, ... 0xFF
	for (i = 0, j = 0, k = 0; i < sdram_size;	i++)
80004d72:	30 08       	mov	r8,0
80004d74:	ef 48 ff f4 	st.w	r7[-12],r8
80004d78:	30 08       	mov	r8,0
80004d7a:	ef 48 ff f8 	st.w	r7[-8],r8
80004d7e:	30 08       	mov	r8,0
80004d80:	ef 48 ff fc 	st.w	r7[-4],r8
80004d84:	c3 78       	rjmp	80004df2 <main+0x146>
	{
		// Write progress indicator to USART
		if (i == k * progress_inc)
80004d86:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d8a:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004d8e:	b1 39       	mul	r9,r8
80004d90:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004d94:	10 39       	cp.w	r9,r8
80004d96:	c1 11       	brne	80004db8 <main+0x10c>
		{
			print_dbg("\rFilling SDRAM with test pattern: ");
80004d98:	4e ec       	lddpc	r12,80004f50 <main+0x2a4>
80004d9a:	f0 1f 00 66 	mcall	80004f30 <main+0x284>
			print_dbg_ulong(k++);
80004d9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da2:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004da6:	2f f9       	sub	r9,-1
80004da8:	ef 49 ff fc 	st.w	r7[-4],r9
80004dac:	10 9c       	mov	r12,r8
80004dae:	f0 1f 00 65 	mcall	80004f40 <main+0x294>
			print_dbg_char('%');
80004db2:	32 5c       	mov	r12,37
80004db4:	f0 1f 00 68 	mcall	80004f54 <main+0x2a8>
		}
		
		// Fill SDRAM byte i with value j, and then increment j
		sdram[i] = j;
80004db8:	4e 88       	lddpc	r8,80004f58 <main+0x2ac>
80004dba:	70 09       	ld.w	r9,r8[0x0]
80004dbc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004dc0:	a3 68       	lsl	r8,0x2
80004dc2:	f2 08 00 08 	add	r8,r9,r8
80004dc6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004dca:	91 09       	st.w	r8[0x0],r9
		j++;
80004dcc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004dd0:	2f f8       	sub	r8,-1
80004dd2:	ef 48 ff f8 	st.w	r7[-8],r8
		
		// Debugger for ensuring the pattern
		if (j > 0xFF)
80004dd6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004dda:	e0 48 00 ff 	cp.w	r8,255
80004dde:	e0 88 00 05 	brls	80004de8 <main+0x13c>
		{
			j = 0;
80004de2:	30 08       	mov	r8,0
80004de4:	ef 48 ff f8 	st.w	r7[-8],r8
	
	// Determine the increment of steps for progress indicator
	progress_inc = (sdram_size + 50) / 100;
	
	// Fill SDRAM with test pattern: 0x00, 0x01, ... 0xFF
	for (i = 0, j = 0, k = 0; i < sdram_size;	i++)
80004de8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004dec:	2f f8       	sub	r8,-1
80004dee:	ef 48 ff f4 	st.w	r7[-12],r8
80004df2:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004df6:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004dfa:	10 39       	cp.w	r9,r8
80004dfc:	cc 53       	brcs	80004d86 <main+0xda>
			j = 0;
		}
	}
	
	// Write confirmation to USART
	print_dbg("\r\nSDRAM filled with test pattern: 0x00, 0x01 ... 0xFF\r\n");
80004dfe:	4d 8c       	lddpc	r12,80004f5c <main+0x2b0>
80004e00:	f0 1f 00 4c 	mcall	80004f30 <main+0x284>
	
	// Ask user to insert SD/MMC
	print_dbg("\r\nInsert SD/MMC...");
80004e04:	4d 7c       	lddpc	r12,80004f60 <main+0x2b4>
80004e06:	f0 1f 00 4b 	mcall	80004f30 <main+0x284>
	
	// Wait for a card to be inserted
	while (!sd_mmc_spi_mem_check());
80004e0a:	f0 1f 00 57 	mcall	80004f64 <main+0x2b8>
80004e0e:	18 98       	mov	r8,r12
80004e10:	ec 18 00 01 	eorl	r8,0x1
80004e14:	5c 58       	castu.b	r8
80004e16:	cf a1       	brne	80004e0a <main+0x15e>
	print_dbg("\r\nCard detected!");
80004e18:	4d 4c       	lddpc	r12,80004f68 <main+0x2bc>
80004e1a:	f0 1f 00 46 	mcall	80004f30 <main+0x284>
	
	// Read Card capacity
	sd_mmc_spi_get_capacity();
80004e1e:	f0 1f 00 54 	mcall	80004f6c <main+0x2c0>
	print_dbg("\r\nCapacity = ");
80004e22:	4d 4c       	lddpc	r12,80004f70 <main+0x2c4>
80004e24:	f0 1f 00 43 	mcall	80004f30 <main+0x284>
	print_dbg_ulong(capacity >> 20);
80004e28:	4d 38       	lddpc	r8,80004f74 <main+0x2c8>
80004e2a:	f0 e8 00 00 	ld.d	r8,r8[0]
80004e2e:	f2 0a 15 0c 	lsl	r10,r9,0xc
80004e32:	f0 02 16 14 	lsr	r2,r8,0x14
80004e36:	f5 e2 10 02 	or	r2,r10,r2
80004e3a:	f2 03 16 14 	lsr	r3,r9,0x14
80004e3e:	04 98       	mov	r8,r2
80004e40:	10 9c       	mov	r12,r8
80004e42:	f0 1f 00 40 	mcall	80004f40 <main+0x294>
	print_dbg(" MBytes\r\n\n");
80004e46:	4c dc       	lddpc	r12,80004f78 <main+0x2cc>
80004e48:	f0 1f 00 3a 	mcall	80004f30 <main+0x284>

	// Initialize PDCA controller before starting a transfer
	local_pdca_init();
80004e4c:	f0 1f 00 4c 	mcall	80004f7c <main+0x2d0>
		
	// Calculate amount of SD/MMC sectors needed to fit entire SDRAM (512 Bytes per sector)
	number_of_sd_sectors = sdram_size / 512;
80004e50:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004e54:	a9 98       	lsr	r8,0x9
80004e56:	ef 48 ff e8 	st.w	r7[-24],r8
	
	// Determine the increment of steps for progress indicator
	progress_inc = number_of_sd_sectors / 100;
80004e5a:	ee f9 ff e8 	ld.w	r9,r7[-24]
80004e5e:	e0 68 85 1f 	mov	r8,34079
80004e62:	ea 18 51 eb 	orh	r8,0x51eb
80004e66:	f2 08 06 48 	mulu.d	r8,r9,r8
80004e6a:	f2 08 16 05 	lsr	r8,r9,0x5
80004e6e:	ef 48 ff ec 	st.w	r7[-20],r8
	
	// Loop for writing entire SDRAM to SD/MMC one sector at a time
	for (i = 0, j = 0; i < number_of_sd_sectors; i++)
80004e72:	30 08       	mov	r8,0
80004e74:	ef 48 ff f4 	st.w	r7[-12],r8
80004e78:	30 08       	mov	r8,0
80004e7a:	ef 48 ff f8 	st.w	r7[-8],r8
80004e7e:	c3 d8       	rjmp	80004ef8 <main+0x24c>
	{
		// Open PCDA write session to SD/MMC sector i
		if (sd_mmc_spi_write_open_PDCA(i))
80004e80:	ee fc ff f4 	ld.w	r12,r7[-12]
80004e84:	f0 1f 00 3f 	mcall	80004f80 <main+0x2d4>
80004e88:	18 98       	mov	r8,r12
80004e8a:	58 08       	cp.w	r8,0
80004e8c:	c1 80       	breq	80004ebc <main+0x210>
		{
			// Load contents of SDRAM on the SPI_TX channel
			pdca_load_channel( AVR32_PDCA_CHANNEL_SPI_TX,sdram,512);
80004e8e:	4b 38       	lddpc	r8,80004f58 <main+0x2ac>
80004e90:	70 08       	ld.w	r8,r8[0x0]
80004e92:	e0 6a 02 00 	mov	r10,512
80004e96:	10 9b       	mov	r11,r8
80004e98:	30 1c       	mov	r12,1
80004e9a:	f0 1f 00 3b 	mcall	80004f84 <main+0x2d8>
			
			// Enable PDCA
			pdca_enable(AVR32_PDCA_CHANNEL_SPI_TX);
80004e9e:	30 1c       	mov	r12,1
80004ea0:	f0 1f 00 3a 	mcall	80004f88 <main+0x2dc>
			
			// Wait for transmission to end
			while (!(pdca_get_transfer_status(AVR32_PDCA_CHANNEL_SPI_TX)&2));
80004ea4:	30 1c       	mov	r12,1
80004ea6:	f0 1f 00 3a 	mcall	80004f8c <main+0x2e0>
80004eaa:	18 98       	mov	r8,r12
80004eac:	e2 18 00 02 	andl	r8,0x2,COH
80004eb0:	cf a0       	breq	80004ea4 <main+0x1f8>
			
			// Disable PDCA
			pdca_disable(AVR32_PDCA_CHANNEL_SPI_TX);
80004eb2:	30 1c       	mov	r12,1
80004eb4:	f0 1f 00 37 	mcall	80004f90 <main+0x2e4>
			
			// Close PCDA write session
			sd_mmc_spi_write_close_PDCA();
80004eb8:	f0 1f 00 37 	mcall	80004f94 <main+0x2e8>
		}
		
		// Write progress indicator to USART
		if (i == j * progress_inc)
80004ebc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004ec0:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ec4:	b1 39       	mul	r9,r8
80004ec6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004eca:	10 39       	cp.w	r9,r8
80004ecc:	c1 11       	brne	80004eee <main+0x242>
		{
			print_dbg("\rTransfering SDRAM to SD/MMC: ");
80004ece:	4b 3c       	lddpc	r12,80004f98 <main+0x2ec>
80004ed0:	f0 1f 00 18 	mcall	80004f30 <main+0x284>
			print_dbg_ulong(j++);
80004ed4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ed8:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004edc:	2f f9       	sub	r9,-1
80004ede:	ef 49 ff f8 	st.w	r7[-8],r9
80004ee2:	10 9c       	mov	r12,r8
80004ee4:	f0 1f 00 17 	mcall	80004f40 <main+0x294>
			print_dbg_char('%');
80004ee8:	32 5c       	mov	r12,37
80004eea:	f0 1f 00 1b 	mcall	80004f54 <main+0x2a8>
	
	// Determine the increment of steps for progress indicator
	progress_inc = number_of_sd_sectors / 100;
	
	// Loop for writing entire SDRAM to SD/MMC one sector at a time
	for (i = 0, j = 0; i < number_of_sd_sectors; i++)
80004eee:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ef2:	2f f8       	sub	r8,-1
80004ef4:	ef 48 ff f4 	st.w	r7[-12],r8
80004ef8:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004efc:	ee f8 ff e8 	ld.w	r8,r7[-24]
80004f00:	10 39       	cp.w	r9,r8
80004f02:	cb f3       	brcs	80004e80 <main+0x1d4>
		}
		
	}
	
	// Write end string to USART
	print_dbg("\r\nTransfer complete!");
80004f04:	4a 6c       	lddpc	r12,80004f9c <main+0x2f0>
80004f06:	f0 1f 00 0b 	mcall	80004f30 <main+0x284>
	print_dbg("\r\nYou can now power down the board and check the contents of the SD/MMC\r\n");
80004f0a:	4a 6c       	lddpc	r12,80004fa0 <main+0x2f4>
80004f0c:	f0 1f 00 09 	mcall	80004f30 <main+0x284>
	print_dbg("\r\n---------------------------------------------------------------------\r\n");
80004f10:	48 ac       	lddpc	r12,80004f38 <main+0x28c>
80004f12:	f0 1f 00 08 	mcall	80004f30 <main+0x284>
	
	
	while (1)
	{
		// Do nothing
	}
80004f16:	c0 08       	rjmp	80004f16 <main+0x26a>
80004f18:	80 00       	ld.sh	r0,r0[0x0]
80004f1a:	56 58       	stdsp	sp[0x194],r8
80004f1c:	80 00       	ld.sh	r0,r0[0x0]
80004f1e:	32 b0       	mov	r0,43
80004f20:	80 00       	ld.sh	r0,r0[0x0]
80004f22:	41 98       	lddsp	r8,sp[0x64]
80004f24:	80 00       	ld.sh	r0,r0[0x0]
80004f26:	43 74       	lddsp	r4,sp[0xdc]
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4c 14       	lddpc	r4,8000502c <memcpy+0x88>
80004f2c:	80 00       	ld.sh	r0,r0[0x0]
80004f2e:	48 28       	lddpc	r8,80004f34 <main+0x288>
80004f30:	80 00       	ld.sh	r0,r0[0x0]
80004f32:	42 18       	lddsp	r8,sp[0x84]
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	48 74       	lddpc	r4,80004f50 <main+0x2a4>
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	48 9c       	lddpc	r12,80004f5c <main+0x2b0>
80004f3c:	80 00       	ld.sh	r0,r0[0x0]
80004f3e:	48 e8       	lddpc	r8,80004f74 <main+0x2c8>
80004f40:	80 00       	ld.sh	r0,r0[0x0]
80004f42:	42 60       	lddsp	r0,sp[0x98]
80004f44:	80 00       	ld.sh	r0,r0[0x0]
80004f46:	48 f8       	lddpc	r8,80004f80 <main+0x2d4>
80004f48:	80 00       	ld.sh	r0,r0[0x0]
80004f4a:	2b a0       	sub	r0,-70
80004f4c:	80 00       	ld.sh	r0,r0[0x0]
80004f4e:	49 00       	lddpc	r0,80004f8c <main+0x2e0>
80004f50:	80 00       	ld.sh	r0,r0[0x0]
80004f52:	49 18       	lddpc	r8,80004f94 <main+0x2e8>
80004f54:	80 00       	ld.sh	r0,r0[0x0]
80004f56:	42 3c       	lddsp	r12,sp[0x8c]
80004f58:	00 00       	add	r0,r0
80004f5a:	00 08       	add	r8,r0
80004f5c:	80 00       	ld.sh	r0,r0[0x0]
80004f5e:	49 3c       	lddpc	r12,80004fa8 <memcpy+0x4>
80004f60:	80 00       	ld.sh	r0,r0[0x0]
80004f62:	49 74       	lddpc	r4,80004fbc <memcpy+0x18>
80004f64:	80 00       	ld.sh	r0,r0[0x0]
80004f66:	2a f0       	sub	r0,-81
80004f68:	80 00       	ld.sh	r0,r0[0x0]
80004f6a:	49 88       	lddpc	r8,80004fc8 <memcpy+0x24>
80004f6c:	80 00       	ld.sh	r0,r0[0x0]
80004f6e:	27 e8       	sub	r8,126
80004f70:	80 00       	ld.sh	r0,r0[0x0]
80004f72:	49 9c       	lddpc	r12,80004fd4 <memcpy+0x30>
80004f74:	00 00       	add	r0,r0
80004f76:	03 18       	ld.sh	r8,r1++
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	49 ac       	lddpc	r12,80004fe0 <memcpy+0x3c>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4b 9c       	lddpc	r12,80005060 <memcpy+0xbc>
80004f80:	80 00       	ld.sh	r0,r0[0x0]
80004f82:	4a 3c       	lddpc	r12,8000500c <memcpy+0x68>
80004f84:	80 00       	ld.sh	r0,r0[0x0]
80004f86:	37 d8       	mov	r8,125
80004f88:	80 00       	ld.sh	r0,r0[0x0]
80004f8a:	37 a8       	mov	r8,122
80004f8c:	80 00       	ld.sh	r0,r0[0x0]
80004f8e:	38 e8       	mov	r8,-114
80004f90:	80 00       	ld.sh	r0,r0[0x0]
80004f92:	37 78       	mov	r8,119
80004f94:	80 00       	ld.sh	r0,r0[0x0]
80004f96:	4a d0       	lddpc	r0,80005048 <memcpy+0xa4>
80004f98:	80 00       	ld.sh	r0,r0[0x0]
80004f9a:	49 b8       	lddpc	r8,80005004 <memcpy+0x60>
80004f9c:	80 00       	ld.sh	r0,r0[0x0]
80004f9e:	49 d8       	lddpc	r8,80005010 <memcpy+0x6c>
80004fa0:	80 00       	ld.sh	r0,r0[0x0]
80004fa2:	49 f0       	lddpc	r0,8000501c <memcpy+0x78>

80004fa4 <memcpy>:
80004fa4:	58 8a       	cp.w	r10,8
80004fa6:	c2 f5       	brlt	80005004 <memcpy+0x60>
80004fa8:	f9 eb 10 09 	or	r9,r12,r11
80004fac:	e2 19 00 03 	andl	r9,0x3,COH
80004fb0:	e0 81 00 97 	brne	800050de <memcpy+0x13a>
80004fb4:	e0 4a 00 20 	cp.w	r10,32
80004fb8:	c3 b4       	brge	8000502e <memcpy+0x8a>
80004fba:	f4 08 14 02 	asr	r8,r10,0x2
80004fbe:	f0 09 11 08 	rsub	r9,r8,8
80004fc2:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80004fc6:	76 69       	ld.w	r9,r11[0x18]
80004fc8:	99 69       	st.w	r12[0x18],r9
80004fca:	76 59       	ld.w	r9,r11[0x14]
80004fcc:	99 59       	st.w	r12[0x14],r9
80004fce:	76 49       	ld.w	r9,r11[0x10]
80004fd0:	99 49       	st.w	r12[0x10],r9
80004fd2:	76 39       	ld.w	r9,r11[0xc]
80004fd4:	99 39       	st.w	r12[0xc],r9
80004fd6:	76 29       	ld.w	r9,r11[0x8]
80004fd8:	99 29       	st.w	r12[0x8],r9
80004fda:	76 19       	ld.w	r9,r11[0x4]
80004fdc:	99 19       	st.w	r12[0x4],r9
80004fde:	76 09       	ld.w	r9,r11[0x0]
80004fe0:	99 09       	st.w	r12[0x0],r9
80004fe2:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80004fe6:	f8 08 00 28 	add	r8,r12,r8<<0x2
80004fea:	e0 1a 00 03 	andl	r10,0x3
80004fee:	f4 0a 11 04 	rsub	r10,r10,4
80004ff2:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80004ff6:	17 a9       	ld.ub	r9,r11[0x2]
80004ff8:	b0 a9       	st.b	r8[0x2],r9
80004ffa:	17 99       	ld.ub	r9,r11[0x1]
80004ffc:	b0 99       	st.b	r8[0x1],r9
80004ffe:	17 89       	ld.ub	r9,r11[0x0]
80005000:	b0 89       	st.b	r8[0x0],r9
80005002:	5e fc       	retal	r12
80005004:	f4 0a 11 09 	rsub	r10,r10,9
80005008:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000500c:	17 f9       	ld.ub	r9,r11[0x7]
8000500e:	b8 f9       	st.b	r12[0x7],r9
80005010:	17 e9       	ld.ub	r9,r11[0x6]
80005012:	b8 e9       	st.b	r12[0x6],r9
80005014:	17 d9       	ld.ub	r9,r11[0x5]
80005016:	b8 d9       	st.b	r12[0x5],r9
80005018:	17 c9       	ld.ub	r9,r11[0x4]
8000501a:	b8 c9       	st.b	r12[0x4],r9
8000501c:	17 b9       	ld.ub	r9,r11[0x3]
8000501e:	b8 b9       	st.b	r12[0x3],r9
80005020:	17 a9       	ld.ub	r9,r11[0x2]
80005022:	b8 a9       	st.b	r12[0x2],r9
80005024:	17 99       	ld.ub	r9,r11[0x1]
80005026:	b8 99       	st.b	r12[0x1],r9
80005028:	17 89       	ld.ub	r9,r11[0x0]
8000502a:	b8 89       	st.b	r12[0x0],r9
8000502c:	5e fc       	retal	r12
8000502e:	eb cd 40 c0 	pushm	r6-r7,lr
80005032:	18 99       	mov	r9,r12
80005034:	22 0a       	sub	r10,32
80005036:	b7 07       	ld.d	r6,r11++
80005038:	b3 26       	st.d	r9++,r6
8000503a:	b7 07       	ld.d	r6,r11++
8000503c:	b3 26       	st.d	r9++,r6
8000503e:	b7 07       	ld.d	r6,r11++
80005040:	b3 26       	st.d	r9++,r6
80005042:	b7 07       	ld.d	r6,r11++
80005044:	b3 26       	st.d	r9++,r6
80005046:	22 0a       	sub	r10,32
80005048:	cf 74       	brge	80005036 <memcpy+0x92>
8000504a:	2f 0a       	sub	r10,-16
8000504c:	c0 65       	brlt	80005058 <memcpy+0xb4>
8000504e:	b7 07       	ld.d	r6,r11++
80005050:	b3 26       	st.d	r9++,r6
80005052:	b7 07       	ld.d	r6,r11++
80005054:	b3 26       	st.d	r9++,r6
80005056:	21 0a       	sub	r10,16
80005058:	5c 3a       	neg	r10
8000505a:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000505e:	d7 03       	nop
80005060:	d7 03       	nop
80005062:	f7 36 00 0e 	ld.ub	r6,r11[14]
80005066:	f3 66 00 0e 	st.b	r9[14],r6
8000506a:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000506e:	f3 66 00 0d 	st.b	r9[13],r6
80005072:	f7 36 00 0c 	ld.ub	r6,r11[12]
80005076:	f3 66 00 0c 	st.b	r9[12],r6
8000507a:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000507e:	f3 66 00 0b 	st.b	r9[11],r6
80005082:	f7 36 00 0a 	ld.ub	r6,r11[10]
80005086:	f3 66 00 0a 	st.b	r9[10],r6
8000508a:	f7 36 00 09 	ld.ub	r6,r11[9]
8000508e:	f3 66 00 09 	st.b	r9[9],r6
80005092:	f7 36 00 08 	ld.ub	r6,r11[8]
80005096:	f3 66 00 08 	st.b	r9[8],r6
8000509a:	f7 36 00 07 	ld.ub	r6,r11[7]
8000509e:	f3 66 00 07 	st.b	r9[7],r6
800050a2:	f7 36 00 06 	ld.ub	r6,r11[6]
800050a6:	f3 66 00 06 	st.b	r9[6],r6
800050aa:	f7 36 00 05 	ld.ub	r6,r11[5]
800050ae:	f3 66 00 05 	st.b	r9[5],r6
800050b2:	f7 36 00 04 	ld.ub	r6,r11[4]
800050b6:	f3 66 00 04 	st.b	r9[4],r6
800050ba:	f7 36 00 03 	ld.ub	r6,r11[3]
800050be:	f3 66 00 03 	st.b	r9[3],r6
800050c2:	f7 36 00 02 	ld.ub	r6,r11[2]
800050c6:	f3 66 00 02 	st.b	r9[2],r6
800050ca:	f7 36 00 01 	ld.ub	r6,r11[1]
800050ce:	f3 66 00 01 	st.b	r9[1],r6
800050d2:	f7 36 00 00 	ld.ub	r6,r11[0]
800050d6:	f3 66 00 00 	st.b	r9[0],r6
800050da:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800050de:	20 1a       	sub	r10,1
800050e0:	f6 0a 07 09 	ld.ub	r9,r11[r10]
800050e4:	f8 0a 0b 09 	st.b	r12[r10],r9
800050e8:	cf b1       	brne	800050de <memcpy+0x13a>
800050ea:	5e fc       	retal	r12

Disassembly of section .exception:

80005200 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80005200:	c0 08       	rjmp	80005200 <_evba>
	...

80005204 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80005204:	c0 08       	rjmp	80005204 <_handle_TLB_Multiple_Hit>
	...

80005208 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80005208:	c0 08       	rjmp	80005208 <_handle_Bus_Error_Data_Fetch>
	...

8000520c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000520c:	c0 08       	rjmp	8000520c <_handle_Bus_Error_Instruction_Fetch>
	...

80005210 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80005210:	c0 08       	rjmp	80005210 <_handle_NMI>
	...

80005214 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80005214:	c0 08       	rjmp	80005214 <_handle_Instruction_Address>
	...

80005218 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80005218:	c0 08       	rjmp	80005218 <_handle_ITLB_Protection>
	...

8000521c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000521c:	c0 08       	rjmp	8000521c <_handle_Breakpoint>
	...

80005220 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80005220:	c0 08       	rjmp	80005220 <_handle_Illegal_Opcode>
	...

80005224 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80005224:	c0 08       	rjmp	80005224 <_handle_Unimplemented_Instruction>
	...

80005228 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80005228:	c0 08       	rjmp	80005228 <_handle_Privilege_Violation>
	...

8000522c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8000522c:	c0 08       	rjmp	8000522c <_handle_Floating_Point>
	...

80005230 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80005230:	c0 08       	rjmp	80005230 <_handle_Coprocessor_Absent>
	...

80005234 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80005234:	c0 08       	rjmp	80005234 <_handle_Data_Address_Read>
	...

80005238 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80005238:	c0 08       	rjmp	80005238 <_handle_Data_Address_Write>
	...

8000523c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000523c:	c0 08       	rjmp	8000523c <_handle_DTLB_Protection_Read>
	...

80005240 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80005240:	c0 08       	rjmp	80005240 <_handle_DTLB_Protection_Write>
	...

80005244 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80005244:	c0 08       	rjmp	80005244 <_handle_DTLB_Modified>
	...

80005250 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80005250:	c0 08       	rjmp	80005250 <_handle_ITLB_Miss>
	...

80005260 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80005260:	c0 08       	rjmp	80005260 <_handle_DTLB_Miss_Read>
	...

80005270 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80005270:	c0 08       	rjmp	80005270 <_handle_DTLB_Miss_Write>
	...

80005300 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80005300:	c0 08       	rjmp	80005300 <_handle_Supervisor_Call>
80005302:	d7 03       	nop

80005304 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005304:	30 0c       	mov	r12,0
80005306:	fe b0 fa 3b 	rcall	8000477c <_get_interrupt_handler>
8000530a:	58 0c       	cp.w	r12,0
8000530c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80005310:	d6 03       	rete

80005312 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005312:	30 1c       	mov	r12,1
80005314:	fe b0 fa 34 	rcall	8000477c <_get_interrupt_handler>
80005318:	58 0c       	cp.w	r12,0
8000531a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000531e:	d6 03       	rete

80005320 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80005320:	30 2c       	mov	r12,2
80005322:	fe b0 fa 2d 	rcall	8000477c <_get_interrupt_handler>
80005326:	58 0c       	cp.w	r12,0
80005328:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000532c:	d6 03       	rete

8000532e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8000532e:	30 3c       	mov	r12,3
80005330:	fe b0 fa 26 	rcall	8000477c <_get_interrupt_handler>
80005334:	58 0c       	cp.w	r12,0
80005336:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000533a:	d6 03       	rete
8000533c:	d7 03       	nop
8000533e:	d7 03       	nop
80005340:	d7 03       	nop
80005342:	d7 03       	nop
80005344:	d7 03       	nop
80005346:	d7 03       	nop
80005348:	d7 03       	nop
8000534a:	d7 03       	nop
8000534c:	d7 03       	nop
8000534e:	d7 03       	nop
80005350:	d7 03       	nop
80005352:	d7 03       	nop
80005354:	d7 03       	nop
80005356:	d7 03       	nop
80005358:	d7 03       	nop
8000535a:	d7 03       	nop
8000535c:	d7 03       	nop
8000535e:	d7 03       	nop
80005360:	d7 03       	nop
80005362:	d7 03       	nop
80005364:	d7 03       	nop
80005366:	d7 03       	nop
80005368:	d7 03       	nop
8000536a:	d7 03       	nop
8000536c:	d7 03       	nop
8000536e:	d7 03       	nop
80005370:	d7 03       	nop
80005372:	d7 03       	nop
80005374:	d7 03       	nop
80005376:	d7 03       	nop
80005378:	d7 03       	nop
8000537a:	d7 03       	nop
8000537c:	d7 03       	nop
8000537e:	d7 03       	nop
80005380:	d7 03       	nop
80005382:	d7 03       	nop
80005384:	d7 03       	nop
80005386:	d7 03       	nop
80005388:	d7 03       	nop
8000538a:	d7 03       	nop
8000538c:	d7 03       	nop
8000538e:	d7 03       	nop
80005390:	d7 03       	nop
80005392:	d7 03       	nop
80005394:	d7 03       	nop
80005396:	d7 03       	nop
80005398:	d7 03       	nop
8000539a:	d7 03       	nop
8000539c:	d7 03       	nop
8000539e:	d7 03       	nop
800053a0:	d7 03       	nop
800053a2:	d7 03       	nop
800053a4:	d7 03       	nop
800053a6:	d7 03       	nop
800053a8:	d7 03       	nop
800053aa:	d7 03       	nop
800053ac:	d7 03       	nop
800053ae:	d7 03       	nop
800053b0:	d7 03       	nop
800053b2:	d7 03       	nop
800053b4:	d7 03       	nop
800053b6:	d7 03       	nop
800053b8:	d7 03       	nop
800053ba:	d7 03       	nop
800053bc:	d7 03       	nop
800053be:	d7 03       	nop
800053c0:	d7 03       	nop
800053c2:	d7 03       	nop
800053c4:	d7 03       	nop
800053c6:	d7 03       	nop
800053c8:	d7 03       	nop
800053ca:	d7 03       	nop
800053cc:	d7 03       	nop
800053ce:	d7 03       	nop
800053d0:	d7 03       	nop
800053d2:	d7 03       	nop
800053d4:	d7 03       	nop
800053d6:	d7 03       	nop
800053d8:	d7 03       	nop
800053da:	d7 03       	nop
800053dc:	d7 03       	nop
800053de:	d7 03       	nop
800053e0:	d7 03       	nop
800053e2:	d7 03       	nop
800053e4:	d7 03       	nop
800053e6:	d7 03       	nop
800053e8:	d7 03       	nop
800053ea:	d7 03       	nop
800053ec:	d7 03       	nop
800053ee:	d7 03       	nop
800053f0:	d7 03       	nop
800053f2:	d7 03       	nop
800053f4:	d7 03       	nop
800053f6:	d7 03       	nop
800053f8:	d7 03       	nop
800053fa:	d7 03       	nop
800053fc:	d7 03       	nop
800053fe:	d7 03       	nop
